strict digraph deps {
"allM" [style=solid];
"andM" [style=solid];
"anyM" [style=solid];
"appendFile" [style=solid];
"appendFileBS" [style=solid];
"appendFileLBS" [style=solid];
"appendFileLText" [style=solid];
"appendFileText" [style=solid];
"appliedTo" [style=solid];
"as" [style=solid];
"asumMap" [style=solid];
"at" [style=solid];
"atomicModifyIORef" [style=solid];
"atomicModifyIORef\'" [style=solid];
"atomicModifyIORef\'_" [style=solid];
"atomicModifyIORef_" [style=solid];
"atomicWriteIORef" [style=solid];
"atomically" [style=solid];
"average" [style=solid];
"average1" [style=solid];
"bimapBoth" [style=solid];
"bimapF" [style=solid];
"bug" [style=solid];
"callerName" [style=solid];
"chainedTo" [style=solid];
"cycle" [style=solid];
"die" [style=solid];
"dup" [style=solid];
"e1" [style=solid];
"elem" [style=solid];
"elems" [style=solid];
"error" [style=solid];
"etaReaderT" [style=solid];
"evaluateNF" [style=solid];
"evaluateNF_" [style=solid];
"evaluateWHNF" [style=solid];
"evaluateWHNF_" [style=solid];
"evaluatingState" [style=solid];
"evaluatingStateT" [style=solid];
"executingState" [style=solid];
"executingStateT" [style=solid];
"exitFailure" [style=solid];
"exitSuccess" [style=solid];
"exitWith" [style=solid];
"firstF" [style=solid];
"flap" [style=solid];
"flipfoldl\'" [style=solid];
"fmapToFst" [style=solid];
"fmapToSnd" [style=solid];
"foldMapA" [style=solid];
"foldMapM" [style=solid];
"foldl1\'" [style=solid];
"foldlSC" [style=solid];
"fromLazy" [style=solid];
"fromLeft" [style=solid];
"fromRight" [style=solid];
"fromStrict" [style=solid];
"getArgs" [style=solid];
"getLine" [style=solid];
"groupBy" [style=solid];
"groupOneBy" [style=solid];
"guardM" [style=solid];
"guarded" [style=solid];
"hFlush" [style=solid];
"hGetBuffering" [style=solid];
"hIsEOF" [style=solid];
"hSetBuffering" [style=solid];
"hashNub" [style=solid];
"head" [style=solid];
"hoistEither" [style=solid];
"hoistMaybe" [style=solid];
"identity" [style=solid];
"ifM" [style=solid];
"impureThrow" [style=solid];
"infinitely" [style=solid];
"infix" [style=solid];
"infixl" [style=solid];
"infixr" [style=solid];
"init" [style=solid];
"integerToBounded" [style=solid];
"integerToNatural" [style=solid];
"inverseMap" [style=solid];
"keys" [style=solid];
"last" [style=solid];
"leftToMaybe" [style=solid];
"lens" [style=solid];
"lines" [style=solid];
"lookupDefault" [style=solid];
"lookupEnv" [style=solid];
"mA" [style=solid];
"mapMaybeM" [style=solid];
"mapToFst" [style=solid];
"mapToSnd" [style=solid];
"maybeToLeft" [style=solid];
"maybeToMonoid" [style=solid];
"maybeToRight" [style=solid];
"memptyIfFalse" [style=solid];
"memptyIfTrue" [style=solid];
"modifyIORef" [style=solid];
"modifyIORef\'" [style=solid];
"newEmptyMVar" [style=solid];
"newEmptyTMVarIO" [style=solid];
"newIORef" [style=solid];
"newMVar" [style=solid];
"newTMVarIO" [style=solid];
"newTVarIO" [style=solid];
"next" [style=solid];
"notElem" [style=solid];
"notMember" [style=solid];
"orM" [style=solid];
"ordNub" [style=solid];
"over" [style=solid];
"ownName" [style=solid];
"partitionWith" [style=solid];
"pass" [style=solid];
"pattern" [style=solid];
"prev" [style=solid];
"print" [style=solid];
"product" [style=solid];
"putBS" [style=solid];
"putBSLn" [style=solid];
"putLBS" [style=solid];
"putLBSLn" [style=solid];
"putLText" [style=solid];
"putLTextLn" [style=solid];
"putMVar" [style=solid];
"putStr" [style=solid];
"putStrLn" [style=solid];
"putText" [style=solid];
"putTextLn" [style=solid];
"readEither" [style=solid];
"readFile" [style=solid];
"readFileBS" [style=solid];
"readFileLBS" [style=solid];
"readFileLText" [style=solid];
"readFileText" [style=solid];
"readIORef" [style=solid];
"readMVar" [style=solid];
"readTVarIO" [style=solid];
"rightToMaybe" [style=solid];
"s" [style=solid];
"safeToEnum" [style=solid];
"secondF" [style=solid];
"set" [style=solid];
"show" [style=solid];
"sortNub" [style=solid];
"sum" [style=solid];
"swapMVar" [style=solid];
"tail" [style=solid];
"takeMVar" [style=solid];
"toFst" [style=solid];
"toPairs" [style=solid];
"toSnd" [style=solid];
"trace" [style=solid];
"traceId" [style=solid];
"traceM" [style=solid];
"traceShow" [style=solid];
"traceShowId" [style=solid];
"traceShowM" [style=solid];
"traceShowWith" [style=solid];
"traverseBoth" [style=solid];
"traverseToFst" [style=solid];
"traverseToSnd" [style=solid];
"tryPutMVar" [style=solid];
"tryReadMVar" [style=solid];
"tryTakeMVar" [style=solid];
"typeName" [style=solid];
"un" [style=solid];
"undefined" [style=solid];
"under" [style=solid];
"under2" [style=solid];
"underF2" [style=solid];
"universe" [style=solid];
"universeNonEmpty" [style=solid];
"unlessM" [style=solid];
"unlines" [style=solid];
"unstableNub" [style=solid];
"unwords" [style=solid];
"usingReader" [style=solid];
"usingReaderT" [style=solid];
"usingState" [style=solid];
"usingStateT" [style=solid];
"viaNonEmpty" [style=solid];
"view" [style=solid];
"whenJust" [style=solid];
"whenJustM" [style=solid];
"whenLeft" [style=solid];
"whenLeftM" [style=solid];
"whenLeftM_" [style=solid];
"whenLeft_" [style=solid];
"whenM" [style=solid];
"whenNotNull" [style=solid];
"whenNotNullM" [style=solid];
"whenNothing" [style=solid];
"whenNothingM" [style=solid];
"whenNothingM_" [style=solid];
"whenNothing_" [style=solid];
"whenRight" [style=solid];
"whenRightM" [style=solid];
"whenRightM_" [style=solid];
"whenRight_" [style=solid];
"words" [style=solid];
"wrap" [style=solid];
"writeFile" [style=solid];
"writeFileBS" [style=solid];
"writeFileLBS" [style=solid];
"writeFileLText" [style=solid];
"writeFileText" [style=solid];
"writeIORef" [style=solid];
"" -> "appliedTo";
"" -> "pass";
"anyM" -> "identity";
"appendFile" -> "hFlush";
"appendFile" -> "hGetBuffering";
"appendFile" -> "hIsEOF";
"appendFile" -> "hSetBuffering";
"appendFileLBS" -> "allM";
"appendFileLBS" -> "andM";
"appendFileLBS" -> "anyM";
"appendFileLBS" -> "asumMap";
"appendFileLBS" -> "elem";
"appendFileLBS" -> "flipfoldl\'";
"appendFileLBS" -> "foldMapA";
"appendFileLBS" -> "foldMapM";
"appendFileLBS" -> "notElem";
"appendFileLBS" -> "orM";
"appendFileLBS" -> "product";
"appendFileLBS" -> "sum";
"appliedTo" -> "guardM";
"appliedTo" -> "guarded";
"appliedTo" -> "ifM";
"appliedTo" -> "unlessM";
"appliedTo" -> "whenM";
"atomicModifyIORef\'_" -> "atomicModifyIORef\'";
"atomicModifyIORef_" -> "atomicModifyIORef";
"atomicWriteIORef" -> "getLine";
"atomicWriteIORef" -> "print";
"atomicWriteIORef" -> "putStr";
"atomicWriteIORef" -> "putStrLn";
"average" -> "as";
"average" -> "average1";
"average" -> "error";
"average" -> "foldl1\'";
"average" -> "head";
"average" -> "last";
"average1" -> "groupBy";
"average1" -> "groupOneBy";
"bug" -> "impureThrow";
"callerName" -> "inverseMap";
"callerName" -> "next";
"callerName" -> "prev";
"callerName" -> "safeToEnum";
"callerName" -> "universe";
"callerName" -> "universeNonEmpty";
"cycle" -> "chainedTo";
"cycle" -> "infinitely";
"die" -> "appendFile";
"die" -> "readFile";
"die" -> "writeFile";
"e1" -> "error";
"e1" -> "trace";
"e1" -> "traceId";
"e1" -> "traceM";
"e1" -> "traceShow";
"e1" -> "traceShowId";
"e1" -> "traceShowM";
"e1" -> "traceShowWith";
"e1" -> "undefined";
"elems" -> "un";
"elems" -> "under";
"elems" -> "under2";
"elems" -> "underF2";
"elems" -> "wrap";
"etaReaderT" -> "s";
"evaluateNF" -> "evaluateWHNF";
"evaluateNF_" -> "bug";
"evaluateNF_" -> "evaluateWHNF";
"evaluateNF_" -> "pattern";
"evaluateWHNF_" -> "evaluateWHNF";
"evaluatingState" -> "s";
"evaluatingState" -> "usingState";
"evaluatingStateT" -> "s";
"evaluatingStateT" -> "usingStateT";
"executingState" -> "s";
"executingState" -> "usingState";
"executingStateT" -> "s";
"executingStateT" -> "usingStateT";
"fmapToFst" -> "toFst";
"fmapToSnd" -> "toSnd";
"fromLazy" -> "s";
"fromStrict" -> "lines";
"fromStrict" -> "unlines";
"fromStrict" -> "unwords";
"fromStrict" -> "words";
"groupBy" -> "flipfoldl\'";
"groupOneBy" -> "flipfoldl\'";
"groupOneBy" -> "lens";
"groupOneBy" -> "over";
"groupOneBy" -> "s";
"groupOneBy" -> "set";
"groupOneBy" -> "view";
"guarded" -> "e1";
"guarded" -> "ifM";
"hGetBuffering" -> "atomicModifyIORef";
"hGetBuffering" -> "atomicModifyIORef\'";
"hGetBuffering" -> "atomicModifyIORef\'_";
"hGetBuffering" -> "atomicModifyIORef_";
"hGetBuffering" -> "atomicWriteIORef";
"hGetBuffering" -> "modifyIORef";
"hGetBuffering" -> "modifyIORef\'";
"hGetBuffering" -> "newIORef";
"hGetBuffering" -> "readIORef";
"hGetBuffering" -> "writeIORef";
"hashNub" -> "s";
"hoistEither" -> "maybeToMonoid";
"hoistEither" -> "memptyIfFalse";
"hoistEither" -> "memptyIfTrue";
"identity" -> "flap";
"infinitely" -> "fromLeft";
"infinitely" -> "fromRight";
"infinitely" -> "leftToMaybe";
"infinitely" -> "maybeToLeft";
"infinitely" -> "maybeToRight";
"infinitely" -> "rightToMaybe";
"infinitely" -> "whenLeft";
"infinitely" -> "whenLeftM";
"infinitely" -> "whenLeftM_";
"infinitely" -> "whenLeft_";
"infinitely" -> "whenRight";
"infinitely" -> "whenRightM";
"infinitely" -> "whenRightM_";
"infinitely" -> "whenRight_";
"infixl" -> "as";
"infixl" -> "atomically";
"infixl" -> "flap";
"infixl" -> "newEmptyMVar";
"infixl" -> "newEmptyTMVarIO";
"infixl" -> "newMVar";
"infixl" -> "newTMVarIO";
"infixl" -> "newTVarIO";
"infixl" -> "putMVar";
"infixl" -> "readMVar";
"infixl" -> "readTVarIO";
"infixl" -> "s";
"infixl" -> "swapMVar";
"infixl" -> "takeMVar";
"infixl" -> "tryPutMVar";
"infixl" -> "tryReadMVar";
"infixl" -> "tryTakeMVar";
"infixl" -> "view";
"infixr" -> "appendFileBS";
"infixr" -> "appendFileLBS";
"infixr" -> "appendFileLText";
"infixr" -> "appendFileText";
"infixr" -> "elems";
"infixr" -> "keys";
"infixr" -> "lookupDefault";
"infixr" -> "mA";
"infixr" -> "notMember";
"infixr" -> "over";
"infixr" -> "readFileBS";
"infixr" -> "readFileLBS";
"infixr" -> "readFileLText";
"infixr" -> "readFileText";
"infixr" -> "s";
"infixr" -> "set";
"infixr" -> "toPairs";
"infixr" -> "writeFileBS";
"infixr" -> "writeFileLBS";
"infixr" -> "writeFileLText";
"infixr" -> "writeFileText";
"integerToNatural" -> "putBS";
"integerToNatural" -> "putBSLn";
"integerToNatural" -> "putLBS";
"integerToNatural" -> "putLBSLn";
"integerToNatural" -> "putLText";
"integerToNatural" -> "putLTextLn";
"integerToNatural" -> "putText";
"integerToNatural" -> "putTextLn";
"inverseMap" -> "fmapToFst";
"inverseMap" -> "universe";
"lens" -> "s";
"lookupEnv" -> "die";
"lookupEnv" -> "exitFailure";
"lookupEnv" -> "exitSuccess";
"lookupEnv" -> "exitWith";
"mapMaybeM" -> "etaReaderT";
"mapMaybeM" -> "evaluatingState";
"mapMaybeM" -> "evaluatingStateT";
"mapMaybeM" -> "executingState";
"mapMaybeM" -> "executingStateT";
"mapMaybeM" -> "hoistEither";
"mapMaybeM" -> "hoistMaybe";
"mapMaybeM" -> "usingReader";
"mapMaybeM" -> "usingReaderT";
"mapMaybeM" -> "usingState";
"mapMaybeM" -> "usingStateT";
"mapToFst" -> "toFst";
"mapToSnd" -> "toSnd";
"memptyIfTrue" -> "hashNub";
"memptyIfTrue" -> "ordNub";
"memptyIfTrue" -> "sortNub";
"memptyIfTrue" -> "unstableNub";
"newEmptyTMVarIO" -> "getArgs";
"newEmptyTMVarIO" -> "lookupEnv";
"ordNub" -> "s";
"partitionWith" -> "head";
"partitionWith" -> "init";
"partitionWith" -> "last";
"partitionWith" -> "tail";
"partitionWith" -> "viaNonEmpty";
"partitionWith" -> "whenNotNull";
"partitionWith" -> "whenNotNullM";
"pattern" -> "bimapBoth";
"pattern" -> "bimapF";
"pattern" -> "firstF";
"pattern" -> "secondF";
"putLBSLn" -> "error";
"putLBSLn" -> "fromLazy";
"putLBSLn" -> "fromStrict";
"putLBSLn" -> "readEither";
"putLBSLn" -> "show";
"putStrLn" -> "partitionWith";
"safeToEnum" -> "average";
"safeToEnum" -> "foldlSC";
"secondF" -> "callerName";
"secondF" -> "ownName";
"set" -> "s";
"show" -> "s";
"tail" -> "cycle";
"traverseBoth" -> "typeName";
"typeName" -> "show";
"undefined" -> "evaluateNF";
"undefined" -> "evaluateNF_";
"undefined" -> "evaluateWHNF";
"undefined" -> "evaluateWHNF_";
"underF2" -> "dup";
"underF2" -> "fmapToFst";
"underF2" -> "fmapToSnd";
"underF2" -> "mapToFst";
"underF2" -> "mapToSnd";
"underF2" -> "toFst";
"underF2" -> "toSnd";
"underF2" -> "traverseBoth";
"underF2" -> "traverseToFst";
"underF2" -> "traverseToSnd";
"unstableNub" -> "integerToBounded";
"unstableNub" -> "integerToNatural";
"unwords" -> "at";
"unwords" -> "head";
"unwords" -> "init";
"unwords" -> "last";
"unwords" -> "tail";
"usingState" -> "s";
"usingStateT" -> "s";
"view" -> "s";
"whenJust" -> "pass";
"whenJustM" -> "whenJust";
"whenLeftM" -> "whenLeft";
"whenLeftM_" -> "whenLeft_";
"whenLeft_" -> "whenLeft";
"whenNotNull" -> "pass";
"whenNotNullM" -> "whenNotNull";
"whenNothingM" -> "whenNothing";
"whenNothingM_" -> "whenNothing_";
"whenNothing_" -> "pass";
"whenRightM" -> "whenRight";
"whenRightM_" -> "mapMaybeM";
"whenRightM_" -> "whenJust";
"whenRightM_" -> "whenJustM";
"whenRightM_" -> "whenNothing";
"whenRightM_" -> "whenNothingM";
"whenRightM_" -> "whenNothingM_";
"whenRightM_" -> "whenNothing_";
"whenRightM_" -> "whenRight_";
"whenRight_" -> "whenRight";
}
