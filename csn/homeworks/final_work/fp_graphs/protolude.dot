strict digraph deps {
"applyN" [style=solid];
"atDef" [style=solid];
"atMay" [style=solid];
"at_" [style=solid];
"bool" [style=solid];
"concatMapM" [style=solid];
"decodeUtf8LT" [style=solid];
"decodeUtf8T" [style=solid];
"die" [style=solid];
"eitherA" [style=solid];
"error" [style=solid];
"f" [style=solid];
"flipSeqScanl\'" [style=solid];
"foldl1May" [style=solid];
"foldl1May\'" [style=solid];
"foldr1May" [style=solid];
"foreach" [style=solid];
"fromLeft" [style=solid];
"fromRight" [style=solid];
"guardM" [style=solid];
"guarded" [style=solid];
"guardedA" [style=solid];
"head" [style=solid];
"headDef" [style=solid];
"headMay" [style=solid];
"hush" [style=solid];
"identity" [style=solid];
"ifM" [style=solid];
"infixl" [style=solid];
"infixr" [style=solid];
"initDef" [style=solid];
"initMay" [style=solid];
"initSafe" [style=solid];
"lastDef" [style=solid];
"lastMay" [style=solid];
"leftToMaybe" [style=solid];
"liftAA2" [style=solid];
"liftIO1" [style=solid];
"liftIO2" [style=solid];
"liftM2\'" [style=solid];
"liftM\'" [style=solid];
"liftMay" [style=solid];
"list" [style=solid];
"map" [style=solid];
"maximumDef" [style=solid];
"maximumMay" [style=solid];
"maybeEmpty" [style=solid];
"maybeToEither" [style=solid];
"maybeToLeft" [style=solid];
"maybeToRight" [style=solid];
"minimumDef" [style=solid];
"minimumMay" [style=solid];
"notImplemented" [style=solid];
"note" [style=solid];
"orAlt" [style=solid];
"orEmpty" [style=solid];
"ordNub" [style=solid];
"panic" [style=solid];
"pass" [style=solid];
"print" [style=solid];
"product" [style=solid];
"purer" [style=solid];
"putByteString" [style=solid];
"putErrText" [style=solid];
"putLByteString" [style=solid];
"putLText" [style=solid];
"putText" [style=solid];
"rightToMaybe" [style=solid];
"scanlFB\'" [style=solid];
"scanl\'" [style=solid];
"show" [style=solid];
"sortOn" [style=solid];
"sum" [style=solid];
"tailDef" [style=solid];
"tailMay" [style=solid];
"tailSafe" [style=solid];
"throwIO" [style=solid];
"throwTo" [style=solid];
"toS" [style=solid];
"toSL" [style=solid];
"toUtf8" [style=solid];
"toUtf8Lazy" [style=solid];
"trace" [style=solid];
"traceIO" [style=solid];
"traceId" [style=solid];
"traceM" [style=solid];
"traceShow" [style=solid];
"traceShowId" [style=solid];
"traceShowM" [style=solid];
"tryIO" [style=solid];
"uncons" [style=solid];
"undefined" [style=solid];
"unlessM" [style=solid];
"unsafeFromJust" [style=solid];
"unsafeHead" [style=solid];
"unsafeIndex" [style=solid];
"unsafeInit" [style=solid];
"unsafeLast" [style=solid];
"unsafeRead" [style=solid];
"unsafeTail" [style=solid];
"unsafeThrow" [style=solid];
"unsnoc" [style=solid];
"void" [style=solid];
"whenM" [style=solid];
"witness" [style=solid];
"x" [style=solid];
"zero" [style=solid];
"" -> "applyN";
"" -> "atDef";
"" -> "atMay";
"" -> "die";
"" -> "foldl1May";
"" -> "foldl1May\'";
"" -> "foldr1May";
"" -> "guarded";
"" -> "guardedA";
"" -> "headDef";
"" -> "headMay";
"" -> "identity";
"" -> "initDef";
"" -> "initMay";
"" -> "initSafe";
"" -> "lastDef";
"" -> "lastMay";
"" -> "liftIO1";
"" -> "liftIO2";
"" -> "map";
"" -> "maximumDef";
"" -> "maximumMay";
"" -> "minimumDef";
"" -> "minimumMay";
"" -> "pass";
"" -> "print";
"" -> "scanl\'";
"" -> "show";
"" -> "tailDef";
"" -> "tailMay";
"" -> "tailSafe";
"" -> "uncons";
"" -> "unsnoc";
"applyN" -> "f";
"applyN" -> "identity";
"atDef" -> "at_";
"atDef" -> "zero";
"atMay" -> "at_";
"at_" -> "f";
"at_" -> "show";
"at_" -> "x";
"bool" -> "f";
"concatMapM" -> "f";
"decodeUtf8LT" -> "toS";
"decodeUtf8LT" -> "toUtf8";
"decodeUtf8LT" -> "toUtf8Lazy";
"eitherA" -> "f";
"error" -> "hush";
"error" -> "note";
"error" -> "tryIO";
"f" -> "bool";
"f" -> "f";
"f" -> "guardM";
"f" -> "ifM";
"f" -> "panic";
"f" -> "unlessM";
"f" -> "whenM";
"f" -> "x";
"flipSeqScanl\'" -> "eitherA";
"flipSeqScanl\'" -> "f";
"flipSeqScanl\'" -> "liftAA2";
"flipSeqScanl\'" -> "orAlt";
"flipSeqScanl\'" -> "orEmpty";
"flipSeqScanl\'" -> "purer";
"foldl1May" -> "liftMay";
"foldr1May" -> "liftMay";
"guardM" -> "f";
"guarded" -> "f";
"guarded" -> "x";
"guardedA" -> "x";
"head" -> "x";
"headDef" -> "headMay";
"headMay" -> "head";
"headMay" -> "liftMay";
"hush" -> "x";
"identity" -> "f";
"identity" -> "x";
"ifM" -> "x";
"infixl" -> "f";
"infixl" -> "foreach";
"infixl" -> "head";
"infixl" -> "list";
"infixl" -> "ordNub";
"infixl" -> "print";
"infixl" -> "product";
"infixl" -> "show";
"infixl" -> "sortOn";
"infixl" -> "sum";
"infixl" -> "x";
"infixr" -> "f";
"infixr" -> "ifM";
"infixr" -> "toS";
"infixr" -> "toSL";
"infixr" -> "x";
"initDef" -> "initMay";
"initMay" -> "liftMay";
"initSafe" -> "initDef";
"lastDef" -> "lastMay";
"lastDef" -> "liftMay";
"lastMay" -> "liftMay";
"liftM2\'" -> "f";
"liftM2\'" -> "x";
"liftMay" -> "f";
"list" -> "f";
"maximumDef" -> "liftMay";
"maximumMay" -> "minimumMay";
"maybeToEither" -> "error";
"minimumDef" -> "maximumMay";
"minimumMay" -> "liftMay";
"notImplemented" -> "error";
"orAlt" -> "f";
"orEmpty" -> "f";
"ordNub" -> "x";
"panic" -> "atDef";
"panic" -> "atMay";
"panic" -> "foldl1May";
"panic" -> "foldl1May\'";
"panic" -> "foldr1May";
"panic" -> "head";
"panic" -> "headDef";
"panic" -> "headMay";
"panic" -> "initDef";
"panic" -> "initMay";
"panic" -> "initSafe";
"panic" -> "lastDef";
"panic" -> "lastMay";
"panic" -> "maximumDef";
"panic" -> "maximumMay";
"panic" -> "minimumDef";
"panic" -> "minimumMay";
"panic" -> "product";
"panic" -> "sum";
"panic" -> "tailDef";
"panic" -> "tailMay";
"panic" -> "tailSafe";
"pass" -> "f";
"product" -> "f";
"purer" -> "f";
"putErrText" -> "unsafeFromJust";
"putErrText" -> "unsafeHead";
"putErrText" -> "unsafeIndex";
"putErrText" -> "unsafeInit";
"putErrText" -> "unsafeLast";
"putErrText" -> "unsafeRead";
"putErrText" -> "unsafeTail";
"putErrText" -> "unsafeThrow";
"scanlFB\'" -> "f";
"scanlFB\'" -> "x";
"scanl\'" -> "f";
"scanl\'" -> "x";
"show" -> "x";
"sum" -> "concatMapM";
"sum" -> "liftM2\'";
"sum" -> "liftM\'";
"tailDef" -> "tailMay";
"tailMay" -> "liftMay";
"tailSafe" -> "tailDef";
"throwTo" -> "f";
"toUtf8" -> "toS";
"toUtf8Lazy" -> "notImplemented";
"toUtf8Lazy" -> "toS";
"toUtf8Lazy" -> "trace";
"toUtf8Lazy" -> "traceIO";
"toUtf8Lazy" -> "traceId";
"toUtf8Lazy" -> "traceM";
"toUtf8Lazy" -> "traceShow";
"toUtf8Lazy" -> "traceShowId";
"toUtf8Lazy" -> "traceShowM";
"toUtf8Lazy" -> "undefined";
"toUtf8Lazy" -> "witness";
"traceId" -> "trace";
"traceM" -> "trace";
"traceShow" -> "trace";
"traceShowId" -> "trace";
"traceShowM" -> "trace";
"tryIO" -> "foreach";
"tryIO" -> "void";
"uncons" -> "x";
"undefined" -> "error";
"unsnoc" -> "x";
"void" -> "x";
"witness" -> "error";
"witness" -> "fromLeft";
"witness" -> "fromRight";
"witness" -> "leftToMaybe";
"witness" -> "maybeEmpty";
"witness" -> "maybeToEither";
"witness" -> "maybeToLeft";
"witness" -> "maybeToRight";
"witness" -> "rightToMaybe";
"zero" -> "putByteString";
"zero" -> "putErrText";
"zero" -> "putLByteString";
"zero" -> "putLText";
"zero" -> "putText";
}
