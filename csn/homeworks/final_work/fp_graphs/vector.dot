strict digraph deps {
"accum" [style=solid];
"accum_stream" [style=solid];
"accumulate" [style=solid];
"accumulate_" [style=solid];
"all" [style=solid];
"and" [style=solid];
"any" [style=solid];
"apply" [style=solid];
"b" [style=solid];
"backpermute" [style=solid];
"break" [style=solid];
"catMaybes" [style=solid];
"check" [style=solid];
"checkError" [style=solid];
"checkIndex" [style=solid];
"checkIndex_msg" [style=solid];
"checkLength" [style=solid];
"checkLength_msg" [style=solid];
"checkSlice" [style=solid];
"checkSlice_msg" [style=solid];
"checkedAdd" [style=solid];
"checkedSubtract" [style=solid];
"chunks" [style=solid];
"clampedSubtract" [style=solid];
"clear" [style=solid];
"clone" [style=solid];
"cmp" [style=solid];
"cmpBy" [style=solid];
"concat" [style=solid];
"concatMap" [style=solid];
"concatMapM" [style=solid];
"concatNE" [style=solid];
"concatVectors" [style=solid];
"cons" [style=solid];
"constructN" [style=solid];
"constructrN" [style=solid];
"consume" [style=solid];
"convert" [style=solid];
"copy" [style=solid];
"create" [style=solid];
"createT" [style=solid];
"dataCast" [style=solid];
"delay_inline" [style=solid];
"delayed_min" [style=solid];
"discard" [style=solid];
"doBoundsChecks" [style=solid];
"doChecks" [style=solid];
"doInternalChecks" [style=solid];
"doUnsafeChecks" [style=solid];
"drop" [style=solid];
"dropWhile" [style=solid];
"dropWhileM" [style=solid];
"elem" [style=solid];
"elemIndex" [style=solid];
"elemIndices" [style=solid];
"elements" [style=solid];
"empty" [style=solid];
"emptyStream" [style=solid];
"enlarge" [style=solid];
"enlargeFront" [style=solid];
"enlarge_delta" [style=solid];
"enumFromN" [style=solid];
"enumFromStepN" [style=solid];
"enumFromThenTo" [style=solid];
"enumFromTo" [style=solid];
"enumFromTo_big_int" [style=solid];
"enumFromTo_big_word" [style=solid];
"enumFromTo_char" [style=solid];
"enumFromTo_double" [style=solid];
"enumFromTo_int" [style=solid];
"enumFromTo_intlike" [style=solid];
"enumFromTo_small" [style=solid];
"eq" [style=solid];
"eqBy" [style=solid];
"error" [style=solid];
"error_msg" [style=solid];
"exchange" [style=solid];
"fill" [style=solid];
"fillR" [style=solid];
"filter" [style=solid];
"filterM" [style=solid];
"find" [style=solid];
"findIndex" [style=solid];
"findIndexM" [style=solid];
"findIndexR" [style=solid];
"findIndices" [style=solid];
"findM" [style=solid];
"flatten" [style=solid];
"fold1M" [style=solid];
"fold1M\'" [style=solid];
"fold1M\'_" [style=solid];
"fold1M_" [style=solid];
"foldM" [style=solid];
"foldM\'" [style=solid];
"foldM\'_" [style=solid];
"foldM_" [style=solid];
"foldl" [style=solid];
"foldl1" [style=solid];
"foldl1M" [style=solid];
"foldl1M\'" [style=solid];
"foldl1\'" [style=solid];
"foldlM" [style=solid];
"foldlM\'" [style=solid];
"foldl\'" [style=solid];
"foldr" [style=solid];
"foldr1" [style=solid];
"foldr1M" [style=solid];
"foldr1\'" [style=solid];
"foldrM" [style=solid];
"foldr\'" [style=solid];
"forM" [style=solid];
"forM_" [style=solid];
"force" [style=solid];
"freeze" [style=solid];
"fromArray" [style=solid];
"fromBool" [style=solid];
"fromList" [style=solid];
"fromListN" [style=solid];
"fromMutableArray" [style=solid];
"fromStream" [style=solid];
"fromVector" [style=solid];
"fromVectors" [style=solid];
"generate" [style=solid];
"generateM" [style=solid];
"getPtr" [style=solid];
"gfoldl" [style=solid];
"grow" [style=solid];
"growFront" [style=solid];
"gunfold" [style=solid];
"head" [style=solid];
"headM" [style=solid];
"ifilter" [style=solid];
"ifoldM" [style=solid];
"ifoldM\'" [style=solid];
"ifoldM\'_" [style=solid];
"ifoldM_" [style=solid];
"ifoldl" [style=solid];
"ifoldl\'" [style=solid];
"ifoldr" [style=solid];
"ifoldr\'" [style=solid];
"iforM" [style=solid];
"iforM_" [style=solid];
"imap" [style=solid];
"imapM" [style=solid];
"imapM_" [style=solid];
"imapMaybe" [style=solid];
"imapMaybeM" [style=solid];
"indexM" [style=solid];
"indexed" [style=solid];
"indexedR" [style=solid];
"infix" [style=solid];
"infixl" [style=solid];
"infixr" [style=solid];
"init" [style=solid];
"inplace" [style=solid];
"internalError" [style=solid];
"isSameVector" [style=solid];
"iscanl" [style=solid];
"iscanl\'" [style=solid];
"iscanr" [style=solid];
"iscanr\'" [style=solid];
"iterateN" [style=solid];
"iterateNM" [style=solid];
"izipWith" [style=solid];
"izipWith3" [style=solid];
"izipWith4" [style=solid];
"izipWith5" [style=solid];
"izipWith6" [style=solid];
"izipWithM" [style=solid];
"izipWithM_" [style=solid];
"larger" [style=solid];
"last" [style=solid];
"lastM" [style=solid];
"length" [style=solid];
"lift" [style=solid];
"liftReadsPrec" [style=solid];
"liftRnfV" [style=solid];
"liftShowsPrec" [style=solid];
"loopM" [style=solid];
"lowerBound" [style=solid];
"mallocVector" [style=solid];
"map" [style=solid];
"mapM" [style=solid];
"mapM_" [style=solid];
"mapMaybe" [style=solid];
"mapMaybeM" [style=solid];
"maxIndex" [style=solid];
"maxIndexBy" [style=solid];
"maximum" [style=solid];
"maximumBy" [style=solid];
"memsetPrimPtr_vector" [style=solid];
"minIndex" [style=solid];
"minIndexBy" [style=solid];
"minimum" [style=solid];
"minimumBy" [style=solid];
"mkType" [style=solid];
"mkVecConstr" [style=solid];
"mkVecType" [style=solid];
"modify" [style=solid];
"modifyWithBundle" [style=solid];
"move" [style=solid];
"moveBackwards" [style=solid];
"moveForwardsLargeOverlap" [style=solid];
"moveForwardsSmallOverlap" [style=solid];
"mstream" [style=solid];
"mstreamR" [style=solid];
"munstream" [style=solid];
"munstreamMax" [style=solid];
"munstreamR" [style=solid];
"munstreamRMax" [style=solid];
"munstreamRUnknown" [style=solid];
"munstreamUnknown" [style=solid];
"new" [style=solid];
"nextPermutation" [style=solid];
"not" [style=solid];
"notElem" [style=solid];
"null" [style=solid];
"or" [style=solid];
"overlaps" [style=solid];
"partition" [style=solid];
"partitionBundle" [style=solid];
"partitionMax" [style=solid];
"partitionUnknown" [style=solid];
"partitionWith" [style=solid];
"partitionWithBundle" [style=solid];
"partitionWithMax" [style=solid];
"partitionWithUnknown" [style=solid];
"partition_stream" [style=solid];
"partition_with_stream" [style=solid];
"peakPrimPtr_vector" [style=solid];
"postscanl" [style=solid];
"postscanlM" [style=solid];
"postscanlM\'" [style=solid];
"postscanl\'" [style=solid];
"postscanr" [style=solid];
"postscanr\'" [style=solid];
"prescanl" [style=solid];
"prescanlM" [style=solid];
"prescanlM\'" [style=solid];
"prescanl\'" [style=solid];
"prescanr" [style=solid];
"prescanr\'" [style=solid];
"product" [style=solid];
"reVector" [style=solid];
"read" [style=solid];
"readPrec" [style=solid];
"replicate" [style=solid];
"replicateM" [style=solid];
"reverse" [style=solid];
"run" [style=solid];
"runPrim" [style=solid];
"s" [style=solid];
"scanl" [style=solid];
"scanl1" [style=solid];
"scanl1M" [style=solid];
"scanl1M\'" [style=solid];
"scanl1\'" [style=solid];
"scanlM" [style=solid];
"scanlM\'" [style=solid];
"scanl\'" [style=solid];
"scanr" [style=solid];
"scanr1" [style=solid];
"scanr1\'" [style=solid];
"scanr\'" [style=solid];
"sequence" [style=solid];
"sequence_" [style=solid];
"set" [style=solid];
"setPtr" [style=solid];
"showsPrec" [style=solid];
"singleton" [style=solid];
"size" [style=solid];
"sized" [style=solid];
"slice" [style=solid];
"smaller" [style=solid];
"smallerThan" [style=solid];
"snoc" [style=solid];
"span" [style=solid];
"splitAt" [style=solid];
"storableSet" [style=solid];
"storableSetAsPrim" [style=solid];
"storableZero" [style=solid];
"stream" [style=solid];
"streamR" [style=solid];
"sum" [style=solid];
"swap" [style=solid];
"tail" [style=solid];
"take" [style=solid];
"takeWhile" [style=solid];
"takeWhileM" [style=solid];
"thaw" [style=solid];
"thawMany" [style=solid];
"toArray" [style=solid];
"toBool" [style=solid];
"toList" [style=solid];
"toListFB" [style=solid];
"toMax" [style=solid];
"toMutableArray" [style=solid];
"trans" [style=solid];
"transform" [style=solid];
"transformR" [style=solid];
"unbox" [style=solid];
"uncons" [style=solid];
"unfoldr" [style=solid];
"unfoldrExactN" [style=solid];
"unfoldrExactNM" [style=solid];
"unfoldrM" [style=solid];
"unfoldrN" [style=solid];
"unfoldrNM" [style=solid];
"uninitialised" [style=solid];
"uniq" [style=solid];
"unsafeAccum" [style=solid];
"unsafeAccum_stream" [style=solid];
"unsafeAccumulate" [style=solid];
"unsafeAccumulate_" [style=solid];
"unsafeAppend1" [style=solid];
"unsafeBackpermute" [style=solid];
"unsafeCast" [style=solid];
"unsafeCoerceMVector" [style=solid];
"unsafeCoerceVector" [style=solid];
"unsafeCopy" [style=solid];
"unsafeDrop" [style=solid];
"unsafeExchange" [style=solid];
"unsafeFreeze" [style=solid];
"unsafeFromForeignPtr" [style=solid];
"unsafeFromForeignPtr0" [style=solid];
"unsafeFromList" [style=solid];
"unsafeGrow" [style=solid];
"unsafeGrowFront" [style=solid];
"unsafeHead" [style=solid];
"unsafeHeadM" [style=solid];
"unsafeIndex" [style=solid];
"unsafeIndexM" [style=solid];
"unsafeInit" [style=solid];
"unsafeLast" [style=solid];
"unsafeLastM" [style=solid];
"unsafeModify" [style=solid];
"unsafeMove" [style=solid];
"unsafeNew" [style=solid];
"unsafePrepend1" [style=solid];
"unsafeRead" [style=solid];
"unsafeSlice" [style=solid];
"unsafeSwap" [style=solid];
"unsafeTail" [style=solid];
"unsafeTake" [style=solid];
"unsafeThaw" [style=solid];
"unsafeToForeignPtr" [style=solid];
"unsafeToForeignPtr0" [style=solid];
"unsafeUpd" [style=solid];
"unsafeUpdate" [style=solid];
"unsafeUpdate_" [style=solid];
"unsafeUpdate_stream" [style=solid];
"unsafeWith" [style=solid];
"unsafeWrite" [style=solid];
"unsnoc" [style=solid];
"unstablePartition" [style=solid];
"unstablePartitionBundle" [style=solid];
"unstablePartitionMax" [style=solid];
"unstablePartition_new" [style=solid];
"unstablePartition_stream" [style=solid];
"unstream" [style=solid];
"unstreamM" [style=solid];
"unstreamPrimM" [style=solid];
"unstreamPrimM_IO" [style=solid];
"unstreamPrimM_ST" [style=solid];
"unstreamR" [style=solid];
"unzip" [style=solid];
"unzip3" [style=solid];
"unzip4" [style=solid];
"unzip5" [style=solid];
"unzip6" [style=solid];
"updPtr" [style=solid];
"update" [style=solid];
"update_" [style=solid];
"update_stream" [style=solid];
"upperBound" [style=solid];
"v" [style=solid];
"vmunstream" [style=solid];
"vmunstreamMax" [style=solid];
"vmunstreamUnknown" [style=solid];
"vunstream" [style=solid];
"write" [style=solid];
"xs" [style=solid];
"zip" [style=solid];
"zip3" [style=solid];
"zip4" [style=solid];
"zip5" [style=solid];
"zip6" [style=solid];
"zipWith" [style=solid];
"zipWith3" [style=solid];
"zipWith3M" [style=solid];
"zipWith4" [style=solid];
"zipWith4M" [style=solid];
"zipWith5" [style=solid];
"zipWith5M" [style=solid];
"zipWith6" [style=solid];
"zipWith6M" [style=solid];
"zipWithM" [style=solid];
"zipWithM_" [style=solid];
"" -> "accum";
"" -> "accumulate";
"" -> "accumulate_";
"" -> "all";
"" -> "and";
"" -> "any";
"" -> "backpermute";
"" -> "break";
"" -> "catMaybes";
"" -> "cmpBy";
"" -> "concat";
"" -> "concatMap";
"" -> "cons";
"" -> "constructN";
"" -> "constructrN";
"" -> "copy";
"" -> "create";
"" -> "createT";
"" -> "drop";
"" -> "dropWhile";
"" -> "elem";
"" -> "elemIndex";
"" -> "elemIndices";
"" -> "empty";
"" -> "enumFromN";
"" -> "enumFromStepN";
"" -> "enumFromThenTo";
"" -> "enumFromTo";
"" -> "eqBy";
"" -> "filter";
"" -> "filterM";
"" -> "find";
"" -> "findIndex";
"" -> "findIndices";
"" -> "fold1M";
"" -> "fold1M\'_";
"" -> "fold1M_";
"" -> "foldM";
"" -> "foldM\'";
"" -> "foldM\'_";
"" -> "foldl";
"" -> "foldl1";
"" -> "foldl1\'";
"" -> "foldl\'";
"" -> "foldr";
"" -> "foldr1";
"" -> "foldr1\'";
"" -> "foldr\'";
"" -> "forM";
"" -> "forM_";
"" -> "force";
"" -> "freeze";
"" -> "fromArray";
"" -> "generate";
"" -> "generateM";
"" -> "head";
"" -> "headM";
"" -> "ifilter";
"" -> "ifoldM";
"" -> "ifoldM\'";
"" -> "ifoldM\'_";
"" -> "ifoldM_";
"" -> "ifoldl";
"" -> "ifoldl\'";
"" -> "ifoldr";
"" -> "ifoldr\'";
"" -> "iforM";
"" -> "iforM_";
"" -> "imap";
"" -> "imapM";
"" -> "imapM_";
"" -> "imapMaybe";
"" -> "imapMaybeM";
"" -> "indexM";
"" -> "indexed";
"" -> "init";
"" -> "iscanl";
"" -> "iscanl\'";
"" -> "iscanr";
"" -> "iscanr\'";
"" -> "iterateN";
"" -> "iterateNM";
"" -> "izipWith";
"" -> "izipWith3";
"" -> "izipWith4";
"" -> "izipWith5";
"" -> "izipWith6";
"" -> "izipWithM";
"" -> "izipWithM_";
"" -> "last";
"" -> "lastM";
"" -> "length";
"" -> "map";
"" -> "mapM";
"" -> "mapM_";
"" -> "mapMaybe";
"" -> "mapMaybeM";
"" -> "maxIndex";
"" -> "maxIndexBy";
"" -> "maximum";
"" -> "maximumBy";
"" -> "minIndex";
"" -> "minIndexBy";
"" -> "minimum";
"" -> "minimumBy";
"" -> "modify";
"" -> "notElem";
"" -> "null";
"" -> "or";
"" -> "partition";
"" -> "partitionWith";
"" -> "postscanl";
"" -> "postscanl\'";
"" -> "postscanr";
"" -> "postscanr\'";
"" -> "prescanl";
"" -> "prescanl\'";
"" -> "prescanr";
"" -> "prescanr\'";
"" -> "product";
"" -> "replicate";
"" -> "replicateM";
"" -> "reverse";
"" -> "scanl";
"" -> "scanl1";
"" -> "scanl1\'";
"" -> "scanl\'";
"" -> "scanr";
"" -> "scanr1";
"" -> "scanr1\'";
"" -> "scanr\'";
"" -> "sequence";
"" -> "sequence_";
"" -> "singleton";
"" -> "slice";
"" -> "snoc";
"" -> "span";
"" -> "splitAt";
"" -> "sum";
"" -> "tail";
"" -> "take";
"" -> "takeWhile";
"" -> "thaw";
"" -> "toArray";
"" -> "toList";
"" -> "uncons";
"" -> "unfoldr";
"" -> "unfoldrExactN";
"" -> "unfoldrExactNM";
"" -> "unfoldrM";
"" -> "unfoldrN";
"" -> "unfoldrNM";
"" -> "uniq";
"" -> "unsafeAccum";
"" -> "unsafeAccumulate";
"" -> "unsafeAccumulate_";
"" -> "unsafeBackpermute";
"" -> "unsafeCopy";
"" -> "unsafeDrop";
"" -> "unsafeFreeze";
"" -> "unsafeHead";
"" -> "unsafeHeadM";
"" -> "unsafeIndex";
"" -> "unsafeIndexM";
"" -> "unsafeInit";
"" -> "unsafeLast";
"" -> "unsafeLastM";
"" -> "unsafeSlice";
"" -> "unsafeTail";
"" -> "unsafeTake";
"" -> "unsafeThaw";
"" -> "unsafeUpd";
"" -> "unsafeUpdate";
"" -> "unsafeUpdate_";
"" -> "unsnoc";
"" -> "unstablePartition";
"" -> "unzip";
"" -> "unzip3";
"" -> "unzip4";
"" -> "unzip5";
"" -> "unzip6";
"" -> "update";
"" -> "update_";
"" -> "zip";
"" -> "zip3";
"" -> "zip4";
"" -> "zip5";
"" -> "zip6";
"" -> "zipWith";
"" -> "zipWith3";
"" -> "zipWith4";
"" -> "zipWith5";
"" -> "zipWith6";
"" -> "zipWithM";
"" -> "zipWithM_";
"accum" -> "accum_stream";
"accum" -> "b";
"accum" -> "length";
"accum" -> "s";
"accum" -> "unsafeRead";
"accum" -> "unsafeWrite";
"accum" -> "v";
"accum_stream" -> "b";
"accum_stream" -> "modifyWithBundle";
"accum_stream" -> "v";
"accumulate" -> "accum_stream";
"accumulate" -> "b";
"accumulate" -> "stream";
"accumulate" -> "v";
"accumulate_" -> "accum_stream";
"accumulate_" -> "b";
"accumulate_" -> "stream";
"accumulate_" -> "v";
"accumulate_" -> "xs";
"all" -> "stream";
"all" -> "v";
"and" -> "s";
"and" -> "stream";
"and" -> "v";
"any" -> "stream";
"any" -> "v";
"apply" -> "s";
"apply" -> "v";
"backpermute" -> "length";
"backpermute" -> "stream";
"backpermute" -> "unstream";
"backpermute" -> "v";
"break" -> "elem";
"break" -> "empty";
"break" -> "findIndex";
"break" -> "length";
"break" -> "unsafeSlice";
"break" -> "xs";
"catMaybes" -> "mapMaybe";
"check" -> "checkError";
"check" -> "doChecks";
"check" -> "not";
"checkError" -> "error";
"checkError" -> "internalError";
"checkIndex" -> "check";
"checkIndex" -> "checkIndex_msg";
"checkIndex_msg" -> "checkIndex_msg";
"checkLength" -> "check";
"checkLength" -> "checkLength_msg";
"checkLength_msg" -> "checkLength_msg";
"checkSlice" -> "check";
"checkSlice" -> "checkSlice_msg";
"checkSlice" -> "clear";
"checkSlice" -> "clone";
"checkSlice" -> "copy";
"checkSlice" -> "drop";
"checkSlice" -> "fromMutableArray";
"checkSlice" -> "grow";
"checkSlice" -> "init";
"checkSlice" -> "length";
"checkSlice" -> "modify";
"checkSlice" -> "move";
"checkSlice" -> "moveBackwards";
"checkSlice" -> "moveForwardsLargeOverlap";
"checkSlice" -> "moveForwardsSmallOverlap";
"checkSlice" -> "new";
"checkSlice" -> "nextPermutation";
"checkSlice" -> "null";
"checkSlice" -> "overlaps";
"checkSlice" -> "read";
"checkSlice" -> "replicate";
"checkSlice" -> "replicateM";
"checkSlice" -> "s";
"checkSlice" -> "set";
"checkSlice" -> "slice";
"checkSlice" -> "splitAt";
"checkSlice" -> "swap";
"checkSlice" -> "tail";
"checkSlice" -> "take";
"checkSlice" -> "toMutableArray";
"checkSlice" -> "uninitialised";
"checkSlice" -> "unsafeCopy";
"checkSlice" -> "unsafeDrop";
"checkSlice" -> "unsafeGrow";
"checkSlice" -> "unsafeInit";
"checkSlice" -> "unsafeModify";
"checkSlice" -> "unsafeMove";
"checkSlice" -> "unsafeNew";
"checkSlice" -> "unsafeRead";
"checkSlice" -> "unsafeSlice";
"checkSlice" -> "unsafeSwap";
"checkSlice" -> "unsafeTail";
"checkSlice" -> "unsafeTake";
"checkSlice" -> "unsafeWrite";
"checkSlice" -> "v";
"checkSlice" -> "write";
"checkSlice_msg" -> "checkSlice_msg";
"checkedAdd" -> "error";
"checkedSubtract" -> "error";
"chunks" -> "v";
"clear" -> "v";
"clone" -> "length";
"clone" -> "unsafeCopy";
"clone" -> "unsafeNew";
"clone" -> "v";
"cmp" -> "b";
"cmp" -> "cmpBy";
"cmp" -> "stream";
"cmp" -> "v";
"cmp" -> "xs";
"cmpBy" -> "b";
"cmpBy" -> "cmp";
"cmpBy" -> "cmpBy";
"cmpBy" -> "eq";
"cmpBy" -> "eqBy";
"cmpBy" -> "stream";
"cmpBy" -> "v";
"cmpBy" -> "xs";
"concat" -> "length";
"concat" -> "unsafeIndexM";
"concat" -> "unstream";
"concat" -> "v";
"concatMap" -> "b";
"concatMap" -> "concatMapM";
"concatMap" -> "length";
"concatMap" -> "stream";
"concatMap" -> "unsafeIndexM";
"concatMap" -> "unstream";
"concatMap" -> "v";
"concatMapM" -> "b";
"concatMapM" -> "fromStream";
"concatMapM" -> "s";
"concatNE" -> "concat";
"concatNE" -> "v";
"concatVectors" -> "b";
"concatVectors" -> "s";
"concatVectors" -> "v";
"cons" -> "s";
"cons" -> "singleton";
"cons" -> "stream";
"cons" -> "unstream";
"cons" -> "v";
"constructN" -> "fill";
"constructN" -> "s";
"constructN" -> "unsafeFreeze";
"constructN" -> "unsafeTake";
"constructN" -> "unsafeThaw";
"constructN" -> "v";
"constructrN" -> "fill";
"constructrN" -> "s";
"constructrN" -> "unsafeFreeze";
"constructrN" -> "unsafeSlice";
"constructrN" -> "unsafeThaw";
"constructrN" -> "v";
"consume" -> "b";
"consume" -> "s";
"convert" -> "stream";
"convert" -> "unstream";
"copy" -> "and";
"copy" -> "b";
"copy" -> "clear";
"copy" -> "clone";
"copy" -> "cmp";
"copy" -> "cmpBy";
"copy" -> "concatMap";
"copy" -> "concatVectors";
"copy" -> "cons";
"copy" -> "copy";
"copy" -> "drop";
"copy" -> "dropWhile";
"copy" -> "elem";
"copy" -> "empty";
"copy" -> "enumFromStepN";
"copy" -> "enumFromThenTo";
"copy" -> "enumFromTo";
"copy" -> "eq";
"copy" -> "eqBy";
"copy" -> "filter";
"copy" -> "filterM";
"copy" -> "find";
"copy" -> "findIndex";
"copy" -> "flatten";
"copy" -> "fold1M";
"copy" -> "fold1M\'";
"copy" -> "foldM";
"copy" -> "foldM\'";
"copy" -> "foldl";
"copy" -> "foldl1";
"copy" -> "foldl1\'";
"copy" -> "foldl\'";
"copy" -> "foldr";
"copy" -> "foldr1";
"copy" -> "fromList";
"copy" -> "fromListN";
"copy" -> "fromVector";
"copy" -> "fromVectors";
"copy" -> "generate";
"copy" -> "gfoldl";
"copy" -> "grow";
"copy" -> "gunfold";
"copy" -> "head";
"copy" -> "indexed";
"copy" -> "indexedR";
"copy" -> "init";
"copy" -> "inplace";
"copy" -> "iterateN";
"copy" -> "last";
"copy" -> "length";
"copy" -> "lift";
"copy" -> "map";
"copy" -> "mapM";
"copy" -> "mapM_";
"copy" -> "mapMaybeM";
"copy" -> "modify";
"copy" -> "move";
"copy" -> "new";
"copy" -> "nextPermutation";
"copy" -> "not";
"copy" -> "notElem";
"copy" -> "null";
"copy" -> "or";
"copy" -> "overlaps";
"copy" -> "postscanl";
"copy" -> "postscanl\'";
"copy" -> "prescanl";
"copy" -> "prescanl\'";
"copy" -> "reVector";
"copy" -> "read";
"copy" -> "replicate";
"copy" -> "replicateM";
"copy" -> "s";
"copy" -> "scanl";
"copy" -> "scanl1";
"copy" -> "scanl1\'";
"copy" -> "scanl\'";
"copy" -> "set";
"copy" -> "singleton";
"copy" -> "size";
"copy" -> "sized";
"copy" -> "slice";
"copy" -> "snoc";
"copy" -> "splitAt";
"copy" -> "swap";
"copy" -> "tail";
"copy" -> "take";
"copy" -> "takeWhile";
"copy" -> "toList";
"copy" -> "unbox";
"copy" -> "unfoldr";
"copy" -> "unfoldrExactN";
"copy" -> "unfoldrN";
"copy" -> "unsafeCoerceMVector";
"copy" -> "unsafeCopy";
"copy" -> "unsafeDrop";
"copy" -> "unsafeFromList";
"copy" -> "unsafeGrow";
"copy" -> "unsafeInit";
"copy" -> "unsafeModify";
"copy" -> "unsafeMove";
"copy" -> "unsafeNew";
"copy" -> "unsafeRead";
"copy" -> "unsafeSlice";
"copy" -> "unsafeSwap";
"copy" -> "unsafeTail";
"copy" -> "unsafeTake";
"copy" -> "unsafeWrite";
"copy" -> "v";
"copy" -> "write";
"copy" -> "zip";
"copy" -> "zip3";
"copy" -> "zip4";
"copy" -> "zip5";
"copy" -> "zip6";
"copy" -> "zipWith";
"copy" -> "zipWith3";
"copy" -> "zipWith4";
"copy" -> "zipWith5";
"copy" -> "zipWith6";
"copy" -> "zipWithM";
"copy" -> "zipWithM_";
"create" -> "new";
"create" -> "s";
"create" -> "v";
"createT" -> "s";
"createT" -> "unsafeFreeze";
"createT" -> "v";
"dataCast" -> "accum";
"dataCast" -> "b";
"dataCast" -> "clear";
"dataCast" -> "clone";
"dataCast" -> "copy";
"dataCast" -> "drop";
"dataCast" -> "exchange";
"dataCast" -> "fill";
"dataCast" -> "fillR";
"dataCast" -> "grow";
"dataCast" -> "growFront";
"dataCast" -> "init";
"dataCast" -> "length";
"dataCast" -> "modify";
"dataCast" -> "move";
"dataCast" -> "mstream";
"dataCast" -> "mstreamR";
"dataCast" -> "munstream";
"dataCast" -> "munstreamR";
"dataCast" -> "new";
"dataCast" -> "nextPermutation";
"dataCast" -> "null";
"dataCast" -> "overlaps";
"dataCast" -> "partitionBundle";
"dataCast" -> "partitionWithBundle";
"dataCast" -> "read";
"dataCast" -> "replicate";
"dataCast" -> "replicateM";
"dataCast" -> "reverse";
"dataCast" -> "set";
"dataCast" -> "slice";
"dataCast" -> "splitAt";
"dataCast" -> "swap";
"dataCast" -> "tail";
"dataCast" -> "take";
"dataCast" -> "transform";
"dataCast" -> "transformR";
"dataCast" -> "unsafeAccum";
"dataCast" -> "unsafeCopy";
"dataCast" -> "unsafeDrop";
"dataCast" -> "unsafeExchange";
"dataCast" -> "unsafeGrow";
"dataCast" -> "unsafeGrowFront";
"dataCast" -> "unsafeInit";
"dataCast" -> "unsafeModify";
"dataCast" -> "unsafeMove";
"dataCast" -> "unsafeNew";
"dataCast" -> "unsafeRead";
"dataCast" -> "unsafeSlice";
"dataCast" -> "unsafeSwap";
"dataCast" -> "unsafeTail";
"dataCast" -> "unsafeTake";
"dataCast" -> "unsafeUpdate";
"dataCast" -> "unsafeWrite";
"dataCast" -> "unstablePartition";
"dataCast" -> "unstablePartitionBundle";
"dataCast" -> "unstream";
"dataCast" -> "unstreamR";
"dataCast" -> "update";
"dataCast" -> "v";
"dataCast" -> "vunstream";
"dataCast" -> "write";
"delayed_min" -> "accum";
"delayed_min" -> "accumulate";
"delayed_min" -> "accumulate_";
"delayed_min" -> "all";
"delayed_min" -> "and";
"delayed_min" -> "any";
"delayed_min" -> "backpermute";
"delayed_min" -> "break";
"delayed_min" -> "clone";
"delayed_min" -> "cmp";
"delayed_min" -> "cmpBy";
"delayed_min" -> "concat";
"delayed_min" -> "concatMap";
"delayed_min" -> "concatNE";
"delayed_min" -> "cons";
"delayed_min" -> "constructN";
"delayed_min" -> "constructrN";
"delayed_min" -> "convert";
"delayed_min" -> "copy";
"delayed_min" -> "create";
"delayed_min" -> "createT";
"delayed_min" -> "dataCast";
"delayed_min" -> "drop";
"delayed_min" -> "dropWhile";
"delayed_min" -> "elem";
"delayed_min" -> "elemIndex";
"delayed_min" -> "elemIndices";
"delayed_min" -> "empty";
"delayed_min" -> "enumFromN";
"delayed_min" -> "enumFromStepN";
"delayed_min" -> "enumFromThenTo";
"delayed_min" -> "enumFromTo";
"delayed_min" -> "eq";
"delayed_min" -> "eqBy";
"delayed_min" -> "filter";
"delayed_min" -> "filterM";
"delayed_min" -> "find";
"delayed_min" -> "findIndex";
"delayed_min" -> "findIndexR";
"delayed_min" -> "findIndices";
"delayed_min" -> "fold1M";
"delayed_min" -> "fold1M\'";
"delayed_min" -> "fold1M\'_";
"delayed_min" -> "fold1M_";
"delayed_min" -> "foldM";
"delayed_min" -> "foldM\'";
"delayed_min" -> "foldM\'_";
"delayed_min" -> "foldM_";
"delayed_min" -> "foldl";
"delayed_min" -> "foldl1";
"delayed_min" -> "foldl1\'";
"delayed_min" -> "foldl\'";
"delayed_min" -> "foldr";
"delayed_min" -> "foldr1";
"delayed_min" -> "foldr1\'";
"delayed_min" -> "foldr\'";
"delayed_min" -> "forM";
"delayed_min" -> "forM_";
"delayed_min" -> "force";
"delayed_min" -> "freeze";
"delayed_min" -> "fromList";
"delayed_min" -> "fromListN";
"delayed_min" -> "generate";
"delayed_min" -> "generateM";
"delayed_min" -> "gfoldl";
"delayed_min" -> "gunfold";
"delayed_min" -> "head";
"delayed_min" -> "headM";
"delayed_min" -> "ifilter";
"delayed_min" -> "ifoldM";
"delayed_min" -> "ifoldM\'";
"delayed_min" -> "ifoldM\'_";
"delayed_min" -> "ifoldM_";
"delayed_min" -> "ifoldl";
"delayed_min" -> "ifoldl\'";
"delayed_min" -> "ifoldr";
"delayed_min" -> "ifoldr\'";
"delayed_min" -> "iforM";
"delayed_min" -> "iforM_";
"delayed_min" -> "imap";
"delayed_min" -> "imapM";
"delayed_min" -> "imapM_";
"delayed_min" -> "imapMaybe";
"delayed_min" -> "imapMaybeM";
"delayed_min" -> "indexM";
"delayed_min" -> "indexed";
"delayed_min" -> "init";
"delayed_min" -> "iscanl";
"delayed_min" -> "iscanl\'";
"delayed_min" -> "iscanr";
"delayed_min" -> "iscanr\'";
"delayed_min" -> "iterateN";
"delayed_min" -> "iterateNM";
"delayed_min" -> "izipWith";
"delayed_min" -> "izipWith3";
"delayed_min" -> "izipWith4";
"delayed_min" -> "izipWith5";
"delayed_min" -> "izipWith6";
"delayed_min" -> "izipWithM";
"delayed_min" -> "izipWithM_";
"delayed_min" -> "last";
"delayed_min" -> "lastM";
"delayed_min" -> "length";
"delayed_min" -> "liftReadsPrec";
"delayed_min" -> "liftShowsPrec";
"delayed_min" -> "map";
"delayed_min" -> "mapM";
"delayed_min" -> "mapM_";
"delayed_min" -> "mapMaybe";
"delayed_min" -> "mapMaybeM";
"delayed_min" -> "maxIndex";
"delayed_min" -> "maxIndexBy";
"delayed_min" -> "maximum";
"delayed_min" -> "maximumBy";
"delayed_min" -> "minIndex";
"delayed_min" -> "minIndexBy";
"delayed_min" -> "minimum";
"delayed_min" -> "minimumBy";
"delayed_min" -> "mkType";
"delayed_min" -> "mkVecConstr";
"delayed_min" -> "mkVecType";
"delayed_min" -> "modify";
"delayed_min" -> "new";
"delayed_min" -> "notElem";
"delayed_min" -> "null";
"delayed_min" -> "or";
"delayed_min" -> "partition";
"delayed_min" -> "partitionWith";
"delayed_min" -> "postscanl";
"delayed_min" -> "postscanl\'";
"delayed_min" -> "postscanr";
"delayed_min" -> "postscanr\'";
"delayed_min" -> "prescanl";
"delayed_min" -> "prescanl\'";
"delayed_min" -> "prescanr";
"delayed_min" -> "prescanr\'";
"delayed_min" -> "product";
"delayed_min" -> "readPrec";
"delayed_min" -> "replicate";
"delayed_min" -> "replicateM";
"delayed_min" -> "reverse";
"delayed_min" -> "scanl";
"delayed_min" -> "scanl1";
"delayed_min" -> "scanl1\'";
"delayed_min" -> "scanl\'";
"delayed_min" -> "scanr";
"delayed_min" -> "scanr1";
"delayed_min" -> "scanr1\'";
"delayed_min" -> "scanr\'";
"delayed_min" -> "sequence";
"delayed_min" -> "sequence_";
"delayed_min" -> "showsPrec";
"delayed_min" -> "singleton";
"delayed_min" -> "slice";
"delayed_min" -> "snoc";
"delayed_min" -> "span";
"delayed_min" -> "splitAt";
"delayed_min" -> "stream";
"delayed_min" -> "streamR";
"delayed_min" -> "sum";
"delayed_min" -> "tail";
"delayed_min" -> "take";
"delayed_min" -> "takeWhile";
"delayed_min" -> "thaw";
"delayed_min" -> "toList";
"delayed_min" -> "uncons";
"delayed_min" -> "unfoldr";
"delayed_min" -> "unfoldrExactN";
"delayed_min" -> "unfoldrExactNM";
"delayed_min" -> "unfoldrM";
"delayed_min" -> "unfoldrN";
"delayed_min" -> "unfoldrNM";
"delayed_min" -> "uniq";
"delayed_min" -> "unsafeAccum";
"delayed_min" -> "unsafeAccumulate";
"delayed_min" -> "unsafeAccumulate_";
"delayed_min" -> "unsafeBackpermute";
"delayed_min" -> "unsafeCopy";
"delayed_min" -> "unsafeDrop";
"delayed_min" -> "unsafeFreeze";
"delayed_min" -> "unsafeHead";
"delayed_min" -> "unsafeHeadM";
"delayed_min" -> "unsafeIndex";
"delayed_min" -> "unsafeIndexM";
"delayed_min" -> "unsafeInit";
"delayed_min" -> "unsafeLast";
"delayed_min" -> "unsafeLastM";
"delayed_min" -> "unsafeSlice";
"delayed_min" -> "unsafeTail";
"delayed_min" -> "unsafeTake";
"delayed_min" -> "unsafeThaw";
"delayed_min" -> "unsafeUpd";
"delayed_min" -> "unsafeUpdate";
"delayed_min" -> "unsafeUpdate_";
"delayed_min" -> "unsnoc";
"delayed_min" -> "unstablePartition";
"delayed_min" -> "unstream";
"delayed_min" -> "unstreamM";
"delayed_min" -> "unstreamR";
"delayed_min" -> "unzip";
"delayed_min" -> "unzip3";
"delayed_min" -> "unzip4";
"delayed_min" -> "unzip5";
"delayed_min" -> "unzip6";
"delayed_min" -> "update";
"delayed_min" -> "update_";
"delayed_min" -> "v";
"delayed_min" -> "zip";
"delayed_min" -> "zip3";
"delayed_min" -> "zip4";
"delayed_min" -> "zip5";
"delayed_min" -> "zip6";
"delayed_min" -> "zipWith";
"delayed_min" -> "zipWith3";
"delayed_min" -> "zipWith4";
"delayed_min" -> "zipWith5";
"delayed_min" -> "zipWith6";
"delayed_min" -> "zipWithM";
"delayed_min" -> "zipWithM_";
"discard" -> "b";
"discard" -> "v";
"doChecks" -> "doBoundsChecks";
"doChecks" -> "doInternalChecks";
"doChecks" -> "doUnsafeChecks";
"drop" -> "apply";
"drop" -> "b";
"drop" -> "clampedSubtract";
"drop" -> "delay_inline";
"drop" -> "fromStream";
"drop" -> "length";
"drop" -> "map";
"drop" -> "s";
"drop" -> "unsafeSlice";
"drop" -> "v";
"dropWhile" -> "dropWhileM";
"dropWhile" -> "elem";
"dropWhile" -> "empty";
"dropWhile" -> "findIndex";
"dropWhile" -> "not";
"dropWhile" -> "unsafeDrop";
"dropWhile" -> "v";
"dropWhile" -> "xs";
"dropWhileM" -> "b";
"dropWhileM" -> "elem";
"dropWhileM" -> "fromStream";
"dropWhileM" -> "s";
"dropWhileM" -> "toMax";
"elem" -> "notElem";
"elem" -> "s";
"elem" -> "stream";
"elemIndex" -> "findIndex";
"elemIndex" -> "v";
"elemIndices" -> "b";
"elemIndices" -> "findIndices";
"elemIndices" -> "v";
"elements" -> "v";
"empty" -> "fromStream";
"empty" -> "unstream";
"empty" -> "v";
"emptyStream" -> "emptyStream";
"emptyStream" -> "s";
"enlarge" -> "enlarge_delta";
"enlarge" -> "length";
"enlarge" -> "unsafeGrow";
"enlarge" -> "v";
"enlargeFront" -> "enlarge_delta";
"enlargeFront" -> "unsafeGrowFront";
"enlargeFront" -> "v";
"enlarge_delta" -> "length";
"enlarge_delta" -> "v";
"enumFromN" -> "enumFromStepN";
"enumFromN" -> "v";
"enumFromStepN" -> "delay_inline";
"enumFromStepN" -> "fromStream";
"enumFromStepN" -> "unstream";
"enumFromStepN" -> "v";
"enumFromThenTo" -> "fromList";
"enumFromThenTo" -> "unstream";
"enumFromThenTo" -> "v";
"enumFromTo" -> "fromList";
"enumFromTo" -> "unstream";
"enumFromTo" -> "v";
"enumFromTo_big_int" -> "fromStream";
"enumFromTo_big_int" -> "v";
"enumFromTo_big_word" -> "fromStream";
"enumFromTo_big_word" -> "v";
"enumFromTo_char" -> "delay_inline";
"enumFromTo_char" -> "fromStream";
"enumFromTo_char" -> "v";
"enumFromTo_double" -> "fromStream";
"enumFromTo_double" -> "v";
"enumFromTo_int" -> "fromStream";
"enumFromTo_int" -> "v";
"enumFromTo_intlike" -> "enumFromTo";
"enumFromTo_intlike" -> "enumFromTo_intlike";
"enumFromTo_intlike" -> "fromStream";
"enumFromTo_intlike" -> "v";
"enumFromTo_small" -> "delay_inline";
"enumFromTo_small" -> "fromStream";
"enumFromTo_small" -> "v";
"eq" -> "b";
"eq" -> "eq";
"eq" -> "eqBy";
"eq" -> "stream";
"eq" -> "v";
"eq" -> "xs";
"eqBy" -> "b";
"eqBy" -> "eq";
"eqBy" -> "stream";
"eqBy" -> "v";
"eqBy" -> "xs";
"error" -> "error_msg";
"exchange" -> "length";
"exchange" -> "unsafeExchange";
"exchange" -> "v";
"fill" -> "length";
"fill" -> "s";
"fill" -> "unsafeSlice";
"fill" -> "unsafeWrite";
"fill" -> "v";
"fillR" -> "length";
"fillR" -> "s";
"fillR" -> "unsafeSlice";
"fillR" -> "unsafeWrite";
"fillR" -> "v";
"filter" -> "b";
"filter" -> "filterM";
"filter" -> "inplace";
"filter" -> "stream";
"filter" -> "toMax";
"filter" -> "unstream";
"filter" -> "v";
"filterM" -> "b";
"filterM" -> "fromStream";
"filterM" -> "lift";
"filterM" -> "s";
"filterM" -> "stream";
"filterM" -> "toMax";
"filterM" -> "unstreamM";
"filterM" -> "v";
"find" -> "findM";
"find" -> "stream";
"find" -> "v";
"findIndex" -> "b";
"findIndex" -> "findIndexM";
"findIndex" -> "stream";
"findIndex" -> "v";
"findIndexM" -> "b";
"findIndexM" -> "s";
"findIndexM" -> "v";
"findIndexR" -> "length";
"findIndexR" -> "streamR";
"findIndexR" -> "v";
"findIndices" -> "inplace";
"findIndices" -> "stream";
"findIndices" -> "toMax";
"findIndices" -> "unstream";
"findIndices" -> "v";
"findM" -> "b";
"findM" -> "s";
"findM" -> "v";
"flatten" -> "and";
"flatten" -> "b";
"flatten" -> "chunks";
"flatten" -> "cmpBy";
"flatten" -> "concatMap";
"flatten" -> "concatMapM";
"flatten" -> "concatVectors";
"flatten" -> "cons";
"flatten" -> "drop";
"flatten" -> "dropWhile";
"flatten" -> "dropWhileM";
"flatten" -> "elem";
"flatten" -> "elements";
"flatten" -> "empty";
"flatten" -> "enumFromStepN";
"flatten" -> "enumFromThenTo";
"flatten" -> "enumFromTo";
"flatten" -> "eqBy";
"flatten" -> "filter";
"flatten" -> "filterM";
"flatten" -> "find";
"flatten" -> "findIndex";
"flatten" -> "findIndexM";
"flatten" -> "findM";
"flatten" -> "flatten";
"flatten" -> "fold1M";
"flatten" -> "fold1M\'";
"flatten" -> "foldM";
"flatten" -> "foldM\'";
"flatten" -> "foldl";
"flatten" -> "foldl1";
"flatten" -> "foldl1M";
"flatten" -> "foldl1M\'";
"flatten" -> "foldl1\'";
"flatten" -> "foldlM";
"flatten" -> "foldlM\'";
"flatten" -> "foldl\'";
"flatten" -> "foldr";
"flatten" -> "foldr1";
"flatten" -> "foldr1M";
"flatten" -> "foldrM";
"flatten" -> "fromList";
"flatten" -> "fromListN";
"flatten" -> "fromStream";
"flatten" -> "fromVector";
"flatten" -> "fromVectors";
"flatten" -> "generate";
"flatten" -> "generateM";
"flatten" -> "head";
"flatten" -> "indexed";
"flatten" -> "indexedR";
"flatten" -> "init";
"flatten" -> "iterateN";
"flatten" -> "iterateNM";
"flatten" -> "last";
"flatten" -> "length";
"flatten" -> "lift";
"flatten" -> "map";
"flatten" -> "mapM";
"flatten" -> "mapM_";
"flatten" -> "mapMaybeM";
"flatten" -> "notElem";
"flatten" -> "null";
"flatten" -> "or";
"flatten" -> "postscanl";
"flatten" -> "postscanlM";
"flatten" -> "postscanlM\'";
"flatten" -> "postscanl\'";
"flatten" -> "prescanl";
"flatten" -> "prescanlM";
"flatten" -> "prescanlM\'";
"flatten" -> "prescanl\'";
"flatten" -> "reVector";
"flatten" -> "replicate";
"flatten" -> "replicateM";
"flatten" -> "s";
"flatten" -> "scanl";
"flatten" -> "scanl1";
"flatten" -> "scanl1M";
"flatten" -> "scanl1M\'";
"flatten" -> "scanl1\'";
"flatten" -> "scanlM";
"flatten" -> "scanlM\'";
"flatten" -> "scanl\'";
"flatten" -> "singleton";
"flatten" -> "size";
"flatten" -> "sized";
"flatten" -> "slice";
"flatten" -> "snoc";
"flatten" -> "tail";
"flatten" -> "take";
"flatten" -> "takeWhile";
"flatten" -> "takeWhileM";
"flatten" -> "toList";
"flatten" -> "trans";
"flatten" -> "unbox";
"flatten" -> "unfoldr";
"flatten" -> "unfoldrExactN";
"flatten" -> "unfoldrExactNM";
"flatten" -> "unfoldrM";
"flatten" -> "unfoldrN";
"flatten" -> "unfoldrNM";
"flatten" -> "unsafeFromList";
"flatten" -> "v";
"flatten" -> "zip";
"flatten" -> "zip3";
"flatten" -> "zip4";
"flatten" -> "zip5";
"flatten" -> "zip6";
"flatten" -> "zipWith";
"flatten" -> "zipWith3";
"flatten" -> "zipWith3M";
"flatten" -> "zipWith4";
"flatten" -> "zipWith4M";
"flatten" -> "zipWith5";
"flatten" -> "zipWith5M";
"flatten" -> "zipWith6";
"flatten" -> "zipWith6M";
"flatten" -> "zipWithM";
"flatten" -> "zipWithM_";
"fold1M" -> "b";
"fold1M" -> "foldl1M";
"fold1M" -> "lift";
"fold1M" -> "stream";
"fold1M" -> "v";
"fold1M\'" -> "b";
"fold1M\'" -> "foldl1M\'";
"fold1M\'" -> "lift";
"fold1M\'" -> "stream";
"fold1M\'" -> "v";
"fold1M\'_" -> "b";
"fold1M\'_" -> "discard";
"fold1M\'_" -> "stream";
"fold1M\'_" -> "v";
"fold1M_" -> "b";
"fold1M_" -> "discard";
"fold1M_" -> "stream";
"fold1M_" -> "v";
"foldM" -> "b";
"foldM" -> "foldlM";
"foldM" -> "lift";
"foldM" -> "stream";
"foldM" -> "v";
"foldM\'" -> "b";
"foldM\'" -> "foldlM\'";
"foldM\'" -> "lift";
"foldM\'" -> "stream";
"foldM\'" -> "v";
"foldM\'_" -> "b";
"foldM\'_" -> "discard";
"foldM\'_" -> "stream";
"foldM\'_" -> "v";
"foldM_" -> "b";
"foldM_" -> "discard";
"foldM_" -> "stream";
"foldM_" -> "v";
"foldl" -> "b";
"foldl" -> "foldlM";
"foldl" -> "stream";
"foldl" -> "v";
"foldl1" -> "b";
"foldl1" -> "foldl1M";
"foldl1" -> "stream";
"foldl1" -> "v";
"foldl1M" -> "foldlM";
"foldl1M" -> "s";
"foldl1M" -> "v";
"foldl1M\'" -> "foldlM\'";
"foldl1M\'" -> "s";
"foldl1M\'" -> "v";
"foldl1\'" -> "b";
"foldl1\'" -> "foldl1M\'";
"foldl1\'" -> "stream";
"foldl1\'" -> "v";
"foldlM" -> "b";
"foldlM" -> "s";
"foldlM" -> "v";
"foldlM\'" -> "b";
"foldlM\'" -> "s";
"foldlM\'" -> "v";
"foldl\'" -> "b";
"foldl\'" -> "foldlM\'";
"foldl\'" -> "stream";
"foldl\'" -> "v";
"foldr" -> "b";
"foldr" -> "foldrM";
"foldr" -> "stream";
"foldr" -> "v";
"foldr1" -> "b";
"foldr1" -> "foldr1M";
"foldr1" -> "stream";
"foldr1" -> "v";
"foldr1M" -> "s";
"foldr1M" -> "v";
"foldr1\'" -> "b";
"foldr1\'" -> "streamR";
"foldr1\'" -> "v";
"foldrM" -> "s";
"foldrM" -> "v";
"foldr\'" -> "streamR";
"foldr\'" -> "v";
"forM" -> "b";
"forM" -> "mapM";
"forM" -> "v";
"forM_" -> "b";
"forM_" -> "mapM_";
"forM_" -> "v";
"force" -> "clone";
"force" -> "new";
"force" -> "update_stream";
"force" -> "v";
"freeze" -> "unsafeFreeze";
"freeze" -> "v";
"fromList" -> "unsafeFromList";
"fromList" -> "unstream";
"fromList" -> "v";
"fromList" -> "xs";
"fromListN" -> "b";
"fromListN" -> "delay_inline";
"fromListN" -> "fromStream";
"fromListN" -> "unstream";
"fromListN" -> "v";
"fromListN" -> "xs";
"fromMutableArray" -> "size";
"fromStream" -> "s";
"fromStream" -> "v";
"fromVector" -> "v";
"fromVectors" -> "v";
"generate" -> "generateM";
"generate" -> "unstream";
"generate" -> "v";
"generateM" -> "delay_inline";
"generateM" -> "fromStream";
"generateM" -> "unstreamM";
"generateM" -> "v";
"gfoldl" -> "b";
"gfoldl" -> "fromList";
"gfoldl" -> "toList";
"gfoldl" -> "v";
"grow" -> "length";
"grow" -> "unsafeGrow";
"grow" -> "v";
"growFront" -> "s";
"growFront" -> "unsafeGrowFront";
"growFront" -> "v";
"gunfold" -> "b";
"gunfold" -> "error";
"gunfold" -> "fromList";
"gunfold" -> "v";
"head" -> "s";
"head" -> "v";
"headM" -> "indexM";
"headM" -> "v";
"ifilter" -> "b";
"ifilter" -> "inplace";
"ifilter" -> "stream";
"ifilter" -> "toMax";
"ifilter" -> "unstream";
"ifilter" -> "v";
"ifoldM" -> "stream";
"ifoldM" -> "v";
"ifoldM\'" -> "stream";
"ifoldM\'" -> "v";
"ifoldM\'_" -> "b";
"ifoldM\'_" -> "discard";
"ifoldM\'_" -> "stream";
"ifoldM\'_" -> "v";
"ifoldM_" -> "discard";
"ifoldM_" -> "stream";
"ifoldM_" -> "v";
"ifoldl" -> "b";
"ifoldl" -> "stream";
"ifoldl" -> "v";
"ifoldl\'" -> "b";
"ifoldl\'" -> "stream";
"ifoldl\'" -> "v";
"ifoldr" -> "b";
"ifoldr" -> "stream";
"ifoldr" -> "v";
"ifoldr\'" -> "length";
"ifoldr\'" -> "streamR";
"ifoldr\'" -> "v";
"ifoldr\'" -> "xs";
"iforM" -> "b";
"iforM" -> "imapM";
"iforM" -> "v";
"iforM_" -> "b";
"iforM_" -> "imapM_";
"iforM_" -> "v";
"imap" -> "b";
"imap" -> "inplace";
"imap" -> "stream";
"imap" -> "unstream";
"imap" -> "v";
"imapM" -> "b";
"imapM" -> "stream";
"imapM" -> "unstreamM";
"imapM" -> "v";
"imapM_" -> "b";
"imapM_" -> "stream";
"imapM_" -> "v";
"imapMaybe" -> "b";
"imapMaybe" -> "inplace";
"imapMaybe" -> "stream";
"imapMaybe" -> "toMax";
"imapMaybe" -> "unstream";
"imapMaybe" -> "v";
"imapMaybeM" -> "b";
"imapMaybeM" -> "stream";
"imapMaybeM" -> "unstreamM";
"imapMaybeM" -> "v";
"indexM" -> "length";
"indexM" -> "v";
"indexed" -> "b";
"indexed" -> "fromStream";
"indexed" -> "s";
"indexed" -> "stream";
"indexed" -> "unstream";
"indexed" -> "v";
"indexedR" -> "b";
"indexedR" -> "fromStream";
"indexedR" -> "s";
"indexedR" -> "v";
"infix" -> "v";
"infixl" -> "b";
"infixl" -> "length";
"infixl" -> "s";
"infixl" -> "v";
"infixr" -> "stream";
"infixr" -> "unstream";
"infixr" -> "v";
"init" -> "apply";
"init" -> "fromStream";
"init" -> "length";
"init" -> "s";
"init" -> "slice";
"init" -> "v";
"inplace" -> "b";
"inplace" -> "v";
"internalError" -> "error_msg";
"isSameVector" -> "b";
"iscanl" -> "b";
"iscanl" -> "inplace";
"iscanl" -> "stream";
"iscanl" -> "unstream";
"iscanl" -> "v";
"iscanl\'" -> "b";
"iscanl\'" -> "inplace";
"iscanl\'" -> "stream";
"iscanl\'" -> "unstream";
"iscanl\'" -> "v";
"iscanr" -> "b";
"iscanr" -> "inplace";
"iscanr" -> "length";
"iscanr" -> "streamR";
"iscanr" -> "unstreamR";
"iscanr" -> "v";
"iscanr\'" -> "inplace";
"iscanr\'" -> "length";
"iscanr\'" -> "streamR";
"iscanr\'" -> "unstreamR";
"iscanr\'" -> "v";
"iterateN" -> "b";
"iterateN" -> "iterateNM";
"iterateN" -> "unstream";
"iterateN" -> "v";
"iterateNM" -> "delay_inline";
"iterateNM" -> "fromStream";
"iterateNM" -> "s";
"iterateNM" -> "unstreamM";
"iterateNM" -> "v";
"izipWith" -> "b";
"izipWith" -> "stream";
"izipWith" -> "unstream";
"izipWith" -> "v";
"izipWith" -> "xs";
"izipWith3" -> "b";
"izipWith3" -> "stream";
"izipWith3" -> "unstream";
"izipWith3" -> "v";
"izipWith4" -> "b";
"izipWith4" -> "stream";
"izipWith4" -> "unstream";
"izipWith4" -> "v";
"izipWith5" -> "b";
"izipWith5" -> "stream";
"izipWith5" -> "unstream";
"izipWith5" -> "v";
"izipWith6" -> "b";
"izipWith6" -> "stream";
"izipWith6" -> "unstream";
"izipWith6" -> "v";
"izipWithM" -> "b";
"izipWithM" -> "stream";
"izipWithM" -> "unstreamM";
"izipWithM" -> "v";
"izipWithM_" -> "b";
"izipWithM_" -> "stream";
"izipWithM_" -> "v";
"larger" -> "delay_inline";
"last" -> "length";
"last" -> "s";
"last" -> "v";
"lastM" -> "indexM";
"lastM" -> "length";
"lastM" -> "v";
"length" -> "foldl\'";
"length" -> "s";
"length" -> "stream";
"length" -> "v";
"lift" -> "s";
"lift" -> "v";
"liftReadsPrec" -> "fromList";
"liftReadsPrec" -> "s";
"liftReadsPrec" -> "v";
"liftRnfV" -> "cmp";
"liftRnfV" -> "concat";
"liftRnfV" -> "concatMap";
"liftRnfV" -> "cons";
"liftRnfV" -> "elem";
"liftRnfV" -> "empty";
"liftRnfV" -> "eq";
"liftRnfV" -> "foldl";
"liftRnfV" -> "foldl1";
"liftRnfV" -> "foldl\'";
"liftRnfV" -> "foldr";
"liftRnfV" -> "foldr1";
"liftRnfV" -> "foldr\'";
"liftRnfV" -> "fromList";
"liftRnfV" -> "fromListN";
"liftRnfV" -> "generate";
"liftRnfV" -> "gfoldl";
"liftRnfV" -> "gunfold";
"liftRnfV" -> "head";
"liftRnfV" -> "headM";
"liftRnfV" -> "length";
"liftRnfV" -> "liftReadsPrec";
"liftRnfV" -> "liftRnfV";
"liftRnfV" -> "liftShowsPrec";
"liftRnfV" -> "map";
"liftRnfV" -> "mapM";
"liftRnfV" -> "maximum";
"liftRnfV" -> "minimum";
"liftRnfV" -> "not";
"liftRnfV" -> "null";
"liftRnfV" -> "product";
"liftRnfV" -> "readPrec";
"liftRnfV" -> "sequence";
"liftRnfV" -> "showsPrec";
"liftRnfV" -> "singleton";
"liftRnfV" -> "sum";
"liftRnfV" -> "toList";
"liftRnfV" -> "unzip";
"liftRnfV" -> "xs";
"liftRnfV" -> "zip";
"liftRnfV" -> "zipWith";
"liftShowsPrec" -> "s";
"liftShowsPrec" -> "toList";
"liftShowsPrec" -> "v";
"mallocVector" -> "b";
"mallocVector" -> "s";
"mallocVector" -> "size";
"map" -> "b";
"map" -> "inplace";
"map" -> "mapM";
"map" -> "stream";
"map" -> "unstream";
"map" -> "v";
"mapM" -> "b";
"mapM" -> "fromStream";
"mapM" -> "lift";
"mapM" -> "s";
"mapM" -> "stream";
"mapM" -> "unstreamM";
"mapM" -> "v";
"mapM_" -> "b";
"mapM_" -> "consume";
"mapM_" -> "lift";
"mapM_" -> "mapM";
"mapM_" -> "stream";
"mapM_" -> "v";
"mapMaybe" -> "b";
"mapMaybe" -> "inplace";
"mapMaybe" -> "s";
"mapMaybe" -> "stream";
"mapMaybe" -> "toMax";
"mapMaybe" -> "unstream";
"mapMaybe" -> "v";
"mapMaybeM" -> "b";
"mapMaybeM" -> "fromStream";
"mapMaybeM" -> "lift";
"mapMaybeM" -> "s";
"mapMaybeM" -> "stream";
"mapMaybeM" -> "toMax";
"mapMaybeM" -> "unstreamM";
"mapMaybeM" -> "v";
"maxIndex" -> "maxIndexBy";
"maxIndex" -> "v";
"maxIndexBy" -> "stream";
"maxIndexBy" -> "v";
"maximum" -> "stream";
"maximum" -> "v";
"maximumBy" -> "stream";
"maximumBy" -> "v";
"minIndex" -> "minIndexBy";
"minIndex" -> "v";
"minIndexBy" -> "b";
"minIndexBy" -> "stream";
"minIndexBy" -> "v";
"minimum" -> "stream";
"minimum" -> "v";
"minimumBy" -> "stream";
"minimumBy" -> "v";
"mkType" -> "v";
"mkVecConstr" -> "mkVecType";
"mkVecType" -> "mkVecConstr";
"modify" -> "b";
"modify" -> "clone";
"modify" -> "length";
"modify" -> "new";
"modify" -> "s";
"modify" -> "unsafeModify";
"modify" -> "v";
"modifyWithBundle" -> "b";
"modifyWithBundle" -> "clone";
"modifyWithBundle" -> "new";
"modifyWithBundle" -> "s";
"modifyWithBundle" -> "v";
"move" -> "length";
"move" -> "unsafeMove";
"move" -> "v";
"moveBackwards" -> "loopM";
"moveForwardsLargeOverlap" -> "loopM";
"moveForwardsLargeOverlap" -> "uninitialised";
"moveForwardsSmallOverlap" -> "loopM";
"moveForwardsSmallOverlap" -> "uninitialised";
"mstream" -> "length";
"mstream" -> "unsafeRead";
"mstream" -> "v";
"mstreamR" -> "length";
"mstreamR" -> "unsafeRead";
"mstreamR" -> "v";
"munstream" -> "munstreamMax";
"munstream" -> "munstreamUnknown";
"munstream" -> "s";
"munstream" -> "upperBound";
"munstream" -> "v";
"munstreamMax" -> "s";
"munstreamMax" -> "unsafeNew";
"munstreamMax" -> "unsafeSlice";
"munstreamMax" -> "unsafeWrite";
"munstreamMax" -> "v";
"munstreamR" -> "munstreamRMax";
"munstreamR" -> "munstreamRUnknown";
"munstreamR" -> "s";
"munstreamR" -> "upperBound";
"munstreamR" -> "v";
"munstreamRMax" -> "s";
"munstreamRMax" -> "unsafeNew";
"munstreamRMax" -> "unsafeSlice";
"munstreamRMax" -> "unsafeWrite";
"munstreamRMax" -> "v";
"munstreamRUnknown" -> "length";
"munstreamRUnknown" -> "s";
"munstreamRUnknown" -> "unsafeNew";
"munstreamRUnknown" -> "unsafePrepend1";
"munstreamRUnknown" -> "unsafeSlice";
"munstreamRUnknown" -> "v";
"munstreamUnknown" -> "length";
"munstreamUnknown" -> "s";
"munstreamUnknown" -> "unsafeAppend1";
"munstreamUnknown" -> "unsafeNew";
"munstreamUnknown" -> "unsafeSlice";
"munstreamUnknown" -> "v";
"new" -> "unsafeFreeze";
"new" -> "unsafeNew";
"new" -> "v";
"nextPermutation" -> "accum";
"nextPermutation" -> "accumulate_";
"nextPermutation" -> "all";
"nextPermutation" -> "and";
"nextPermutation" -> "any";
"nextPermutation" -> "apply";
"nextPermutation" -> "b";
"nextPermutation" -> "backpermute";
"nextPermutation" -> "break";
"nextPermutation" -> "cmpBy";
"nextPermutation" -> "concat";
"nextPermutation" -> "concatMap";
"nextPermutation" -> "cons";
"nextPermutation" -> "constructN";
"nextPermutation" -> "constructrN";
"nextPermutation" -> "copy";
"nextPermutation" -> "create";
"nextPermutation" -> "createT";
"nextPermutation" -> "drop";
"nextPermutation" -> "dropWhile";
"nextPermutation" -> "elem";
"nextPermutation" -> "elemIndex";
"nextPermutation" -> "elemIndices";
"nextPermutation" -> "empty";
"nextPermutation" -> "enumFromN";
"nextPermutation" -> "enumFromStepN";
"nextPermutation" -> "enumFromThenTo";
"nextPermutation" -> "enumFromTo";
"nextPermutation" -> "eqBy";
"nextPermutation" -> "filter";
"nextPermutation" -> "filterM";
"nextPermutation" -> "find";
"nextPermutation" -> "findIndex";
"nextPermutation" -> "findIndices";
"nextPermutation" -> "fold1M";
"nextPermutation" -> "fold1M\'";
"nextPermutation" -> "fold1M\'_";
"nextPermutation" -> "fold1M_";
"nextPermutation" -> "foldM";
"nextPermutation" -> "foldM\'";
"nextPermutation" -> "foldM\'_";
"nextPermutation" -> "foldM_";
"nextPermutation" -> "foldl";
"nextPermutation" -> "foldl1";
"nextPermutation" -> "foldl1\'";
"nextPermutation" -> "foldl\'";
"nextPermutation" -> "foldr";
"nextPermutation" -> "foldr1";
"nextPermutation" -> "foldr1\'";
"nextPermutation" -> "foldr\'";
"nextPermutation" -> "forM";
"nextPermutation" -> "forM_";
"nextPermutation" -> "force";
"nextPermutation" -> "freeze";
"nextPermutation" -> "fromList";
"nextPermutation" -> "fromListN";
"nextPermutation" -> "generate";
"nextPermutation" -> "generateM";
"nextPermutation" -> "head";
"nextPermutation" -> "headM";
"nextPermutation" -> "ifilter";
"nextPermutation" -> "ifoldM";
"nextPermutation" -> "ifoldM\'";
"nextPermutation" -> "ifoldM\'_";
"nextPermutation" -> "ifoldM_";
"nextPermutation" -> "ifoldl";
"nextPermutation" -> "ifoldl\'";
"nextPermutation" -> "ifoldr";
"nextPermutation" -> "ifoldr\'";
"nextPermutation" -> "iforM";
"nextPermutation" -> "iforM_";
"nextPermutation" -> "imap";
"nextPermutation" -> "imapM";
"nextPermutation" -> "imapM_";
"nextPermutation" -> "imapMaybe";
"nextPermutation" -> "imapMaybeM";
"nextPermutation" -> "indexM";
"nextPermutation" -> "init";
"nextPermutation" -> "isSameVector";
"nextPermutation" -> "iscanl";
"nextPermutation" -> "iscanl\'";
"nextPermutation" -> "iscanr";
"nextPermutation" -> "iscanr\'";
"nextPermutation" -> "iterateN";
"nextPermutation" -> "iterateNM";
"nextPermutation" -> "izipWith";
"nextPermutation" -> "izipWith3";
"nextPermutation" -> "izipWith4";
"nextPermutation" -> "izipWith5";
"nextPermutation" -> "izipWith6";
"nextPermutation" -> "izipWithM";
"nextPermutation" -> "izipWithM_";
"nextPermutation" -> "last";
"nextPermutation" -> "lastM";
"nextPermutation" -> "length";
"nextPermutation" -> "map";
"nextPermutation" -> "mapM";
"nextPermutation" -> "mapM_";
"nextPermutation" -> "mapMaybe";
"nextPermutation" -> "mapMaybeM";
"nextPermutation" -> "maxIndex";
"nextPermutation" -> "maxIndexBy";
"nextPermutation" -> "maximum";
"nextPermutation" -> "maximumBy";
"nextPermutation" -> "minIndex";
"nextPermutation" -> "minIndexBy";
"nextPermutation" -> "minimum";
"nextPermutation" -> "minimumBy";
"nextPermutation" -> "modify";
"nextPermutation" -> "modifyWithBundle";
"nextPermutation" -> "notElem";
"nextPermutation" -> "null";
"nextPermutation" -> "or";
"nextPermutation" -> "partition";
"nextPermutation" -> "partitionWith";
"nextPermutation" -> "postscanl";
"nextPermutation" -> "postscanl\'";
"nextPermutation" -> "postscanr";
"nextPermutation" -> "postscanr\'";
"nextPermutation" -> "prescanl";
"nextPermutation" -> "prescanl\'";
"nextPermutation" -> "prescanr";
"nextPermutation" -> "prescanr\'";
"nextPermutation" -> "product";
"nextPermutation" -> "replicate";
"nextPermutation" -> "replicateM";
"nextPermutation" -> "reverse";
"nextPermutation" -> "run";
"nextPermutation" -> "runPrim";
"nextPermutation" -> "s";
"nextPermutation" -> "scanl";
"nextPermutation" -> "scanl1";
"nextPermutation" -> "scanl1\'";
"nextPermutation" -> "scanl\'";
"nextPermutation" -> "scanr";
"nextPermutation" -> "scanr1";
"nextPermutation" -> "scanr1\'";
"nextPermutation" -> "scanr\'";
"nextPermutation" -> "singleton";
"nextPermutation" -> "slice";
"nextPermutation" -> "snoc";
"nextPermutation" -> "span";
"nextPermutation" -> "splitAt";
"nextPermutation" -> "sum";
"nextPermutation" -> "tail";
"nextPermutation" -> "take";
"nextPermutation" -> "takeWhile";
"nextPermutation" -> "thaw";
"nextPermutation" -> "toList";
"nextPermutation" -> "transform";
"nextPermutation" -> "transformR";
"nextPermutation" -> "uncons";
"nextPermutation" -> "unfoldr";
"nextPermutation" -> "unfoldrExactN";
"nextPermutation" -> "unfoldrExactNM";
"nextPermutation" -> "unfoldrM";
"nextPermutation" -> "unfoldrN";
"nextPermutation" -> "unfoldrNM";
"nextPermutation" -> "uniq";
"nextPermutation" -> "unsafeAccum";
"nextPermutation" -> "unsafeAccumulate_";
"nextPermutation" -> "unsafeBackpermute";
"nextPermutation" -> "unsafeCast";
"nextPermutation" -> "unsafeCoerceVector";
"nextPermutation" -> "unsafeCopy";
"nextPermutation" -> "unsafeDrop";
"nextPermutation" -> "unsafeFreeze";
"nextPermutation" -> "unsafeFromForeignPtr";
"nextPermutation" -> "unsafeFromForeignPtr0";
"nextPermutation" -> "unsafeHead";
"nextPermutation" -> "unsafeHeadM";
"nextPermutation" -> "unsafeIndex";
"nextPermutation" -> "unsafeIndexM";
"nextPermutation" -> "unsafeInit";
"nextPermutation" -> "unsafeLast";
"nextPermutation" -> "unsafeLastM";
"nextPermutation" -> "unsafeRead";
"nextPermutation" -> "unsafeSlice";
"nextPermutation" -> "unsafeSwap";
"nextPermutation" -> "unsafeTail";
"nextPermutation" -> "unsafeTake";
"nextPermutation" -> "unsafeThaw";
"nextPermutation" -> "unsafeToForeignPtr";
"nextPermutation" -> "unsafeToForeignPtr0";
"nextPermutation" -> "unsafeUpd";
"nextPermutation" -> "unsafeUpdate_";
"nextPermutation" -> "unsafeWith";
"nextPermutation" -> "unsnoc";
"nextPermutation" -> "unstablePartition";
"nextPermutation" -> "unstream";
"nextPermutation" -> "unstreamR";
"nextPermutation" -> "unzip";
"nextPermutation" -> "unzip3";
"nextPermutation" -> "update_";
"nextPermutation" -> "v";
"nextPermutation" -> "zip";
"nextPermutation" -> "zip3";
"nextPermutation" -> "zipWith";
"nextPermutation" -> "zipWith3";
"nextPermutation" -> "zipWith4";
"nextPermutation" -> "zipWith5";
"nextPermutation" -> "zipWith6";
"nextPermutation" -> "zipWithM";
"nextPermutation" -> "zipWithM_";
"notElem" -> "elem";
"notElem" -> "not";
"notElem" -> "s";
"notElem" -> "stream";
"notElem" -> "v";
"null" -> "length";
"null" -> "s";
"null" -> "stream";
"null" -> "v";
"or" -> "b";
"or" -> "s";
"or" -> "stream";
"or" -> "v";
"overlaps" -> "v";
"partition" -> "partition_stream";
"partition" -> "stream";
"partition" -> "v";
"partitionBundle" -> "partitionMax";
"partitionBundle" -> "partitionUnknown";
"partitionBundle" -> "s";
"partitionBundle" -> "upperBound";
"partitionBundle" -> "v";
"partitionMax" -> "reverse";
"partitionMax" -> "s";
"partitionMax" -> "unsafeNew";
"partitionMax" -> "unsafeSlice";
"partitionMax" -> "unsafeWrite";
"partitionMax" -> "v";
"partitionUnknown" -> "b";
"partitionUnknown" -> "length";
"partitionUnknown" -> "s";
"partitionUnknown" -> "unsafeAppend1";
"partitionUnknown" -> "unsafeNew";
"partitionUnknown" -> "unsafeSlice";
"partitionUnknown" -> "v";
"partitionWith" -> "b";
"partitionWith" -> "partition_with_stream";
"partitionWith" -> "stream";
"partitionWith" -> "v";
"partitionWithBundle" -> "b";
"partitionWithBundle" -> "partitionWithMax";
"partitionWithBundle" -> "partitionWithUnknown";
"partitionWithBundle" -> "s";
"partitionWithBundle" -> "upperBound";
"partitionWithBundle" -> "v";
"partitionWithMax" -> "b";
"partitionWithMax" -> "length";
"partitionWithMax" -> "s";
"partitionWithMax" -> "unsafeNew";
"partitionWithMax" -> "unsafeSlice";
"partitionWithMax" -> "unsafeWrite";
"partitionWithMax" -> "v";
"partitionWithUnknown" -> "b";
"partitionWithUnknown" -> "length";
"partitionWithUnknown" -> "s";
"partitionWithUnknown" -> "unsafeAppend1";
"partitionWithUnknown" -> "unsafeNew";
"partitionWithUnknown" -> "unsafeSlice";
"partitionWithUnknown" -> "v";
"partition_stream" -> "b";
"partition_stream" -> "s";
"partition_stream" -> "unsafeFreeze";
"partition_stream" -> "v";
"partition_with_stream" -> "s";
"partition_with_stream" -> "unsafeFreeze";
"partition_with_stream" -> "v";
"postscanl" -> "b";
"postscanl" -> "inplace";
"postscanl" -> "postscanlM";
"postscanl" -> "stream";
"postscanl" -> "unstream";
"postscanl" -> "v";
"postscanlM" -> "b";
"postscanlM" -> "fromStream";
"postscanlM" -> "s";
"postscanlM" -> "v";
"postscanlM\'" -> "b";
"postscanlM\'" -> "fromStream";
"postscanlM\'" -> "s";
"postscanlM\'" -> "v";
"postscanl\'" -> "b";
"postscanl\'" -> "inplace";
"postscanl\'" -> "postscanlM\'";
"postscanl\'" -> "stream";
"postscanl\'" -> "unstream";
"postscanl\'" -> "v";
"postscanr" -> "b";
"postscanr" -> "inplace";
"postscanr" -> "streamR";
"postscanr" -> "unstreamR";
"postscanr" -> "v";
"postscanr\'" -> "b";
"postscanr\'" -> "inplace";
"postscanr\'" -> "streamR";
"postscanr\'" -> "unstreamR";
"postscanr\'" -> "v";
"prescanl" -> "b";
"prescanl" -> "inplace";
"prescanl" -> "prescanlM";
"prescanl" -> "stream";
"prescanl" -> "unstream";
"prescanl" -> "v";
"prescanlM" -> "b";
"prescanlM" -> "fromStream";
"prescanlM" -> "s";
"prescanlM" -> "v";
"prescanlM\'" -> "b";
"prescanlM\'" -> "fromStream";
"prescanlM\'" -> "s";
"prescanlM\'" -> "v";
"prescanl\'" -> "b";
"prescanl\'" -> "inplace";
"prescanl\'" -> "prescanlM\'";
"prescanl\'" -> "stream";
"prescanl\'" -> "unstream";
"prescanl\'" -> "v";
"prescanr" -> "b";
"prescanr" -> "inplace";
"prescanr" -> "streamR";
"prescanr" -> "unstreamR";
"prescanr" -> "v";
"prescanr\'" -> "b";
"prescanr\'" -> "inplace";
"prescanr\'" -> "streamR";
"prescanr\'" -> "unstreamR";
"prescanr\'" -> "v";
"product" -> "stream";
"product" -> "v";
"reVector" -> "b";
"reVector" -> "checkedAdd";
"reVector" -> "checkedSubtract";
"reVector" -> "clampedSubtract";
"reVector" -> "delay_inline";
"reVector" -> "delayed_min";
"reVector" -> "error";
"reVector" -> "fromStream";
"reVector" -> "larger";
"reVector" -> "lowerBound";
"reVector" -> "s";
"reVector" -> "smaller";
"reVector" -> "smallerThan";
"reVector" -> "toMax";
"reVector" -> "upperBound";
"reVector" -> "v";
"read" -> "length";
"read" -> "unsafeRead";
"read" -> "v";
"readPrec" -> "fromList";
"readPrec" -> "v";
"readPrec" -> "xs";
"replicate" -> "delay_inline";
"replicate" -> "replicateM";
"replicate" -> "unstream";
"replicate" -> "v";
"replicateM" -> "delay_inline";
"replicateM" -> "fromStream";
"replicateM" -> "munstream";
"replicateM" -> "unstreamM";
"replicateM" -> "v";
"reverse" -> "length";
"reverse" -> "streamR";
"reverse" -> "unsafeSwap";
"reverse" -> "unstream";
"reverse" -> "v";
"run" -> "v";
"runPrim" -> "s";
"runPrim" -> "v";
"scanl" -> "b";
"scanl" -> "scanlM";
"scanl" -> "stream";
"scanl" -> "unstream";
"scanl" -> "v";
"scanl1" -> "inplace";
"scanl1" -> "scanl1M";
"scanl1" -> "stream";
"scanl1" -> "unstream";
"scanl1" -> "v";
"scanl1M" -> "fromStream";
"scanl1M" -> "s";
"scanl1M" -> "v";
"scanl1M\'" -> "fromStream";
"scanl1M\'" -> "s";
"scanl1M\'" -> "v";
"scanl1\'" -> "b";
"scanl1\'" -> "inplace";
"scanl1\'" -> "scanl1M\'";
"scanl1\'" -> "stream";
"scanl1\'" -> "unstream";
"scanl1\'" -> "v";
"scanlM" -> "b";
"scanlM" -> "cons";
"scanlM" -> "postscanlM";
"scanlM" -> "s";
"scanlM" -> "v";
"scanlM\'" -> "cons";
"scanlM\'" -> "postscanlM";
"scanlM\'" -> "s";
"scanlM\'" -> "v";
"scanl\'" -> "b";
"scanl\'" -> "scanlM\'";
"scanl\'" -> "stream";
"scanl\'" -> "unstream";
"scanl\'" -> "v";
"scanr" -> "b";
"scanr" -> "streamR";
"scanr" -> "unstreamR";
"scanr" -> "v";
"scanr1" -> "inplace";
"scanr1" -> "streamR";
"scanr1" -> "unstreamR";
"scanr1" -> "v";
"scanr1\'" -> "b";
"scanr1\'" -> "inplace";
"scanr1\'" -> "streamR";
"scanr1\'" -> "unstreamR";
"scanr1\'" -> "v";
"scanr\'" -> "b";
"scanr\'" -> "streamR";
"scanr\'" -> "unstreamR";
"scanr\'" -> "v";
"sequence" -> "mapM";
"sequence" -> "v";
"sequence_" -> "b";
"sequence_" -> "mapM_";
"sequence_" -> "v";
"set" -> "v";
"showsPrec" -> "toList";
"showsPrec" -> "v";
"singleton" -> "fromStream";
"singleton" -> "unstream";
"singleton" -> "v";
"size" -> "v";
"sized" -> "s";
"sized" -> "v";
"slice" -> "apply";
"slice" -> "drop";
"slice" -> "length";
"slice" -> "s";
"slice" -> "take";
"slice" -> "unsafeSlice";
"slice" -> "v";
"smaller" -> "delay_inline";
"smallerThan" -> "delay_inline";
"snoc" -> "s";
"snoc" -> "singleton";
"snoc" -> "stream";
"snoc" -> "unstream";
"snoc" -> "v";
"span" -> "break";
"span" -> "not";
"span" -> "v";
"splitAt" -> "delay_inline";
"splitAt" -> "length";
"splitAt" -> "s";
"splitAt" -> "unsafeSlice";
"splitAt" -> "v";
"storableSet" -> "storableSetAsPrim";
"storableSetAsPrim" -> "b";
"storableSetAsPrim" -> "memsetPrimPtr_vector";
"storableSetAsPrim" -> "peakPrimPtr_vector";
"storableZero" -> "memsetPrimPtr_vector";
"stream" -> "v";
"streamR" -> "length";
"streamR" -> "v";
"sum" -> "stream";
"sum" -> "v";
"swap" -> "length";
"swap" -> "unsafeSwap";
"swap" -> "v";
"tail" -> "apply";
"tail" -> "fromStream";
"tail" -> "length";
"tail" -> "s";
"tail" -> "slice";
"tail" -> "v";
"take" -> "apply";
"take" -> "delay_inline";
"take" -> "fromStream";
"take" -> "length";
"take" -> "s";
"take" -> "smallerThan";
"take" -> "unsafeSlice";
"take" -> "v";
"takeWhile" -> "stream";
"takeWhile" -> "takeWhileM";
"takeWhile" -> "unstream";
"takeWhile" -> "v";
"takeWhileM" -> "b";
"takeWhileM" -> "fromStream";
"takeWhileM" -> "s";
"takeWhileM" -> "toMax";
"takeWhileM" -> "v";
"thaw" -> "length";
"thaw" -> "unsafeCopy";
"thaw" -> "v";
"thawMany" -> "length";
"thawMany" -> "unsafeCopy";
"thawMany" -> "v";
"toArray" -> "size";
"toBool" -> "b";
"toBool" -> "clear";
"toBool" -> "clone";
"toBool" -> "copy";
"toBool" -> "drop";
"toBool" -> "fromBool";
"toBool" -> "grow";
"toBool" -> "init";
"toBool" -> "length";
"toBool" -> "modify";
"toBool" -> "move";
"toBool" -> "new";
"toBool" -> "nextPermutation";
"toBool" -> "null";
"toBool" -> "overlaps";
"toBool" -> "read";
"toBool" -> "replicate";
"toBool" -> "replicateM";
"toBool" -> "s";
"toBool" -> "set";
"toBool" -> "slice";
"toBool" -> "splitAt";
"toBool" -> "swap";
"toBool" -> "tail";
"toBool" -> "take";
"toBool" -> "toBool";
"toBool" -> "unsafeCopy";
"toBool" -> "unsafeDrop";
"toBool" -> "unsafeGrow";
"toBool" -> "unsafeInit";
"toBool" -> "unsafeModify";
"toBool" -> "unsafeMove";
"toBool" -> "unsafeNew";
"toBool" -> "unsafeRead";
"toBool" -> "unsafeSlice";
"toBool" -> "unsafeSwap";
"toBool" -> "unsafeTail";
"toBool" -> "unsafeTake";
"toBool" -> "unsafeWrite";
"toBool" -> "unzip";
"toBool" -> "unzip3";
"toBool" -> "unzip4";
"toBool" -> "unzip5";
"toBool" -> "unzip6";
"toBool" -> "v";
"toBool" -> "write";
"toBool" -> "zip";
"toBool" -> "zip3";
"toBool" -> "zip4";
"toBool" -> "zip5";
"toBool" -> "zip6";
"toList" -> "b";
"toList" -> "foldr";
"toList" -> "s";
"toList" -> "stream";
"toList" -> "toListFB";
"toList" -> "v";
"toListFB" -> "s";
"toListFB" -> "v";
"toMutableArray" -> "accum";
"toMutableArray" -> "accumulate_";
"toMutableArray" -> "all";
"toMutableArray" -> "any";
"toMutableArray" -> "b";
"toMutableArray" -> "backpermute";
"toMutableArray" -> "break";
"toMutableArray" -> "cmpBy";
"toMutableArray" -> "concat";
"toMutableArray" -> "concatMap";
"toMutableArray" -> "cons";
"toMutableArray" -> "constructN";
"toMutableArray" -> "constructrN";
"toMutableArray" -> "copy";
"toMutableArray" -> "create";
"toMutableArray" -> "createT";
"toMutableArray" -> "drop";
"toMutableArray" -> "dropWhile";
"toMutableArray" -> "elem";
"toMutableArray" -> "elemIndex";
"toMutableArray" -> "elemIndices";
"toMutableArray" -> "empty";
"toMutableArray" -> "enumFromN";
"toMutableArray" -> "enumFromStepN";
"toMutableArray" -> "enumFromThenTo";
"toMutableArray" -> "enumFromTo";
"toMutableArray" -> "eqBy";
"toMutableArray" -> "filter";
"toMutableArray" -> "filterM";
"toMutableArray" -> "find";
"toMutableArray" -> "findIndex";
"toMutableArray" -> "findIndices";
"toMutableArray" -> "fold1M";
"toMutableArray" -> "fold1M\'";
"toMutableArray" -> "fold1M\'_";
"toMutableArray" -> "fold1M_";
"toMutableArray" -> "foldM";
"toMutableArray" -> "foldM\'";
"toMutableArray" -> "foldM\'_";
"toMutableArray" -> "foldM_";
"toMutableArray" -> "foldl";
"toMutableArray" -> "foldl1";
"toMutableArray" -> "foldl1\'";
"toMutableArray" -> "foldl\'";
"toMutableArray" -> "foldr";
"toMutableArray" -> "foldr1";
"toMutableArray" -> "foldr1\'";
"toMutableArray" -> "foldr\'";
"toMutableArray" -> "forM";
"toMutableArray" -> "forM_";
"toMutableArray" -> "force";
"toMutableArray" -> "freeze";
"toMutableArray" -> "fromList";
"toMutableArray" -> "fromListN";
"toMutableArray" -> "generate";
"toMutableArray" -> "generateM";
"toMutableArray" -> "head";
"toMutableArray" -> "headM";
"toMutableArray" -> "ifilter";
"toMutableArray" -> "ifoldM";
"toMutableArray" -> "ifoldM\'";
"toMutableArray" -> "ifoldM\'_";
"toMutableArray" -> "ifoldM_";
"toMutableArray" -> "ifoldl";
"toMutableArray" -> "ifoldl\'";
"toMutableArray" -> "ifoldr";
"toMutableArray" -> "ifoldr\'";
"toMutableArray" -> "iforM";
"toMutableArray" -> "iforM_";
"toMutableArray" -> "imap";
"toMutableArray" -> "imapM";
"toMutableArray" -> "imapM_";
"toMutableArray" -> "imapMaybe";
"toMutableArray" -> "imapMaybeM";
"toMutableArray" -> "indexM";
"toMutableArray" -> "init";
"toMutableArray" -> "iscanl";
"toMutableArray" -> "iscanl\'";
"toMutableArray" -> "iscanr";
"toMutableArray" -> "iscanr\'";
"toMutableArray" -> "iterateN";
"toMutableArray" -> "iterateNM";
"toMutableArray" -> "izipWith";
"toMutableArray" -> "izipWith3";
"toMutableArray" -> "izipWith4";
"toMutableArray" -> "izipWith5";
"toMutableArray" -> "izipWith6";
"toMutableArray" -> "izipWithM";
"toMutableArray" -> "izipWithM_";
"toMutableArray" -> "last";
"toMutableArray" -> "lastM";
"toMutableArray" -> "length";
"toMutableArray" -> "map";
"toMutableArray" -> "mapM";
"toMutableArray" -> "mapM_";
"toMutableArray" -> "mapMaybe";
"toMutableArray" -> "mapMaybeM";
"toMutableArray" -> "maxIndex";
"toMutableArray" -> "maxIndexBy";
"toMutableArray" -> "maximum";
"toMutableArray" -> "maximumBy";
"toMutableArray" -> "minIndex";
"toMutableArray" -> "minIndexBy";
"toMutableArray" -> "minimum";
"toMutableArray" -> "minimumBy";
"toMutableArray" -> "modify";
"toMutableArray" -> "notElem";
"toMutableArray" -> "null";
"toMutableArray" -> "partition";
"toMutableArray" -> "partitionWith";
"toMutableArray" -> "postscanl";
"toMutableArray" -> "postscanl\'";
"toMutableArray" -> "postscanr";
"toMutableArray" -> "postscanr\'";
"toMutableArray" -> "prescanl";
"toMutableArray" -> "prescanl\'";
"toMutableArray" -> "prescanr";
"toMutableArray" -> "prescanr\'";
"toMutableArray" -> "product";
"toMutableArray" -> "replicate";
"toMutableArray" -> "replicateM";
"toMutableArray" -> "reverse";
"toMutableArray" -> "scanl";
"toMutableArray" -> "scanl1";
"toMutableArray" -> "scanl1\'";
"toMutableArray" -> "scanl\'";
"toMutableArray" -> "scanr";
"toMutableArray" -> "scanr1";
"toMutableArray" -> "scanr1\'";
"toMutableArray" -> "scanr\'";
"toMutableArray" -> "singleton";
"toMutableArray" -> "size";
"toMutableArray" -> "slice";
"toMutableArray" -> "snoc";
"toMutableArray" -> "span";
"toMutableArray" -> "splitAt";
"toMutableArray" -> "sum";
"toMutableArray" -> "tail";
"toMutableArray" -> "take";
"toMutableArray" -> "takeWhile";
"toMutableArray" -> "thaw";
"toMutableArray" -> "toList";
"toMutableArray" -> "uncons";
"toMutableArray" -> "unfoldr";
"toMutableArray" -> "unfoldrExactN";
"toMutableArray" -> "unfoldrExactNM";
"toMutableArray" -> "unfoldrM";
"toMutableArray" -> "unfoldrN";
"toMutableArray" -> "unfoldrNM";
"toMutableArray" -> "uniq";
"toMutableArray" -> "unsafeAccum";
"toMutableArray" -> "unsafeAccumulate_";
"toMutableArray" -> "unsafeBackpermute";
"toMutableArray" -> "unsafeCoerceVector";
"toMutableArray" -> "unsafeCopy";
"toMutableArray" -> "unsafeDrop";
"toMutableArray" -> "unsafeFreeze";
"toMutableArray" -> "unsafeHead";
"toMutableArray" -> "unsafeHeadM";
"toMutableArray" -> "unsafeIndex";
"toMutableArray" -> "unsafeIndexM";
"toMutableArray" -> "unsafeInit";
"toMutableArray" -> "unsafeLast";
"toMutableArray" -> "unsafeLastM";
"toMutableArray" -> "unsafeSlice";
"toMutableArray" -> "unsafeTail";
"toMutableArray" -> "unsafeTake";
"toMutableArray" -> "unsafeThaw";
"toMutableArray" -> "unsafeUpd";
"toMutableArray" -> "unsafeUpdate_";
"toMutableArray" -> "unsnoc";
"toMutableArray" -> "unstablePartition";
"toMutableArray" -> "unzip";
"toMutableArray" -> "unzip3";
"toMutableArray" -> "update_";
"toMutableArray" -> "zip";
"toMutableArray" -> "zip3";
"toMutableArray" -> "zipWith";
"toMutableArray" -> "zipWith3";
"toMutableArray" -> "zipWith4";
"toMutableArray" -> "zipWith5";
"toMutableArray" -> "zipWith6";
"toMutableArray" -> "zipWithM";
"toMutableArray" -> "zipWithM_";
"trans" -> "s";
"trans" -> "v";
"transform" -> "fill";
"transform" -> "mstream";
"transform" -> "v";
"transformR" -> "fillR";
"transformR" -> "mstreamR";
"transformR" -> "v";
"unbox" -> "b";
"unbox" -> "fromStream";
"unbox" -> "s";
"unbox" -> "v";
"uncons" -> "unsafeTail";
"uncons" -> "v";
"uncons" -> "xs";
"unfoldr" -> "b";
"unfoldr" -> "s";
"unfoldr" -> "unfoldrM";
"unfoldr" -> "unstream";
"unfoldr" -> "v";
"unfoldrExactN" -> "b";
"unfoldrExactN" -> "s";
"unfoldrExactN" -> "unfoldrExactNM";
"unfoldrExactN" -> "unstream";
"unfoldrExactN" -> "v";
"unfoldrExactNM" -> "delay_inline";
"unfoldrExactNM" -> "fromStream";
"unfoldrExactNM" -> "s";
"unfoldrExactNM" -> "unstreamM";
"unfoldrExactNM" -> "v";
"unfoldrM" -> "b";
"unfoldrM" -> "fromStream";
"unfoldrM" -> "s";
"unfoldrM" -> "unstreamM";
"unfoldrM" -> "v";
"unfoldrN" -> "b";
"unfoldrN" -> "s";
"unfoldrN" -> "unfoldrNM";
"unfoldrN" -> "unstream";
"unfoldrN" -> "v";
"unfoldrNM" -> "b";
"unfoldrNM" -> "delay_inline";
"unfoldrNM" -> "fromStream";
"unfoldrNM" -> "s";
"unfoldrNM" -> "unstreamM";
"unfoldrNM" -> "v";
"uninitialised" -> "error";
"uninitialised" -> "s";
"uniq" -> "b";
"uniq" -> "inplace";
"uniq" -> "s";
"uniq" -> "stream";
"uniq" -> "toMax";
"uniq" -> "unstream";
"uniq" -> "v";
"unsafeAccum" -> "b";
"unsafeAccum" -> "length";
"unsafeAccum" -> "s";
"unsafeAccum" -> "unsafeAccum_stream";
"unsafeAccum" -> "unsafeRead";
"unsafeAccum" -> "unsafeWrite";
"unsafeAccum" -> "v";
"unsafeAccum_stream" -> "b";
"unsafeAccum_stream" -> "modifyWithBundle";
"unsafeAccum_stream" -> "v";
"unsafeAccumulate" -> "b";
"unsafeAccumulate" -> "stream";
"unsafeAccumulate" -> "unsafeAccum_stream";
"unsafeAccumulate" -> "v";
"unsafeAccumulate_" -> "b";
"unsafeAccumulate_" -> "stream";
"unsafeAccumulate_" -> "unsafeAccum_stream";
"unsafeAccumulate_" -> "v";
"unsafeAccumulate_" -> "xs";
"unsafeAppend1" -> "enlarge";
"unsafeAppend1" -> "length";
"unsafeAppend1" -> "unsafeWrite";
"unsafeAppend1" -> "v";
"unsafeBackpermute" -> "length";
"unsafeBackpermute" -> "s";
"unsafeBackpermute" -> "stream";
"unsafeBackpermute" -> "unstream";
"unsafeBackpermute" -> "v";
"unsafeCast" -> "b";
"unsafeCast" -> "s";
"unsafeCoerceMVector" -> "error";
"unsafeCoerceMVector" -> "getPtr";
"unsafeCoerceMVector" -> "mallocVector";
"unsafeCoerceMVector" -> "s";
"unsafeCoerceMVector" -> "size";
"unsafeCoerceMVector" -> "storableSet";
"unsafeCoerceMVector" -> "storableZero";
"unsafeCoerceMVector" -> "updPtr";
"unsafeCoerceMVector" -> "v";
"unsafeCoerceVector" -> "concat";
"unsafeCoerceVector" -> "empty";
"unsafeCoerceVector" -> "fromList";
"unsafeCoerceVector" -> "fromListN";
"unsafeCoerceVector" -> "gfoldl";
"unsafeCoerceVector" -> "gunfold";
"unsafeCoerceVector" -> "not";
"unsafeCoerceVector" -> "readPrec";
"unsafeCoerceVector" -> "showsPrec";
"unsafeCoerceVector" -> "toList";
"unsafeCoerceVector" -> "updPtr";
"unsafeCoerceVector" -> "xs";
"unsafeCopy" -> "length";
"unsafeCopy" -> "not";
"unsafeCopy" -> "overlaps";
"unsafeCopy" -> "v";
"unsafeDrop" -> "length";
"unsafeDrop" -> "s";
"unsafeDrop" -> "unsafeSlice";
"unsafeDrop" -> "v";
"unsafeExchange" -> "length";
"unsafeExchange" -> "unsafeRead";
"unsafeExchange" -> "unsafeWrite";
"unsafeExchange" -> "v";
"unsafeFreeze" -> "v";
"unsafeFromForeignPtr" -> "s";
"unsafeFromForeignPtr" -> "unsafeFromForeignPtr0";
"unsafeFromForeignPtr" -> "updPtr";
"unsafeFromForeignPtr0" -> "s";
"unsafeFromList" -> "fromStream";
"unsafeFromList" -> "v";
"unsafeFromList" -> "xs";
"unsafeGrow" -> "v";
"unsafeGrowFront" -> "length";
"unsafeGrowFront" -> "v";
"unsafeHead" -> "unsafeIndex";
"unsafeHead" -> "v";
"unsafeHeadM" -> "unsafeIndexM";
"unsafeHeadM" -> "v";
"unsafeIndex" -> "length";
"unsafeIndex" -> "v";
"unsafeIndexM" -> "length";
"unsafeIndexM" -> "v";
"unsafeInit" -> "apply";
"unsafeInit" -> "length";
"unsafeInit" -> "s";
"unsafeInit" -> "unsafeSlice";
"unsafeInit" -> "v";
"unsafeLast" -> "length";
"unsafeLast" -> "unsafeIndex";
"unsafeLast" -> "v";
"unsafeLastM" -> "length";
"unsafeLastM" -> "unsafeIndexM";
"unsafeLastM" -> "v";
"unsafeModify" -> "length";
"unsafeModify" -> "v";
"unsafeMove" -> "b";
"unsafeMove" -> "length";
"unsafeMove" -> "s";
"unsafeMove" -> "v";
"unsafeNew" -> "v";
"unsafePrepend1" -> "enlargeFront";
"unsafePrepend1" -> "length";
"unsafePrepend1" -> "unsafeWrite";
"unsafePrepend1" -> "v";
"unsafeRead" -> "length";
"unsafeRead" -> "v";
"unsafeSlice" -> "apply";
"unsafeSlice" -> "length";
"unsafeSlice" -> "s";
"unsafeSlice" -> "v";
"unsafeSwap" -> "length";
"unsafeSwap" -> "unsafeRead";
"unsafeSwap" -> "unsafeWrite";
"unsafeSwap" -> "v";
"unsafeTail" -> "apply";
"unsafeTail" -> "check";
"unsafeTail" -> "checkIndex";
"unsafeTail" -> "checkLength";
"unsafeTail" -> "checkSlice";
"unsafeTail" -> "doChecks";
"unsafeTail" -> "error";
"unsafeTail" -> "internalError";
"unsafeTail" -> "length";
"unsafeTail" -> "s";
"unsafeTail" -> "unsafeSlice";
"unsafeTail" -> "v";
"unsafeTake" -> "s";
"unsafeTake" -> "unsafeSlice";
"unsafeTake" -> "v";
"unsafeThaw" -> "v";
"unsafeToForeignPtr" -> "s";
"unsafeToForeignPtr0" -> "b";
"unsafeUpd" -> "unsafeUpdate_stream";
"unsafeUpd" -> "v";
"unsafeUpdate" -> "b";
"unsafeUpdate" -> "length";
"unsafeUpdate" -> "s";
"unsafeUpdate" -> "stream";
"unsafeUpdate" -> "unsafeUpdate_stream";
"unsafeUpdate" -> "unsafeWrite";
"unsafeUpdate" -> "v";
"unsafeUpdate_" -> "b";
"unsafeUpdate_" -> "stream";
"unsafeUpdate_" -> "unsafeUpdate_stream";
"unsafeUpdate_" -> "v";
"unsafeUpdate_stream" -> "modifyWithBundle";
"unsafeUpdate_stream" -> "v";
"unsafeWith" -> "accum";
"unsafeWith" -> "accumulate";
"unsafeWith" -> "accumulate_";
"unsafeWith" -> "all";
"unsafeWith" -> "and";
"unsafeWith" -> "any";
"unsafeWith" -> "backpermute";
"unsafeWith" -> "break";
"unsafeWith" -> "cmpBy";
"unsafeWith" -> "concat";
"unsafeWith" -> "concatMap";
"unsafeWith" -> "cons";
"unsafeWith" -> "constructN";
"unsafeWith" -> "constructrN";
"unsafeWith" -> "copy";
"unsafeWith" -> "create";
"unsafeWith" -> "createT";
"unsafeWith" -> "drop";
"unsafeWith" -> "dropWhile";
"unsafeWith" -> "elem";
"unsafeWith" -> "elemIndex";
"unsafeWith" -> "elemIndices";
"unsafeWith" -> "empty";
"unsafeWith" -> "enumFromN";
"unsafeWith" -> "enumFromStepN";
"unsafeWith" -> "enumFromThenTo";
"unsafeWith" -> "enumFromTo";
"unsafeWith" -> "eqBy";
"unsafeWith" -> "filter";
"unsafeWith" -> "filterM";
"unsafeWith" -> "find";
"unsafeWith" -> "findIndex";
"unsafeWith" -> "findIndices";
"unsafeWith" -> "fold1M";
"unsafeWith" -> "fold1M\'";
"unsafeWith" -> "fold1M\'_";
"unsafeWith" -> "fold1M_";
"unsafeWith" -> "foldM";
"unsafeWith" -> "foldM\'";
"unsafeWith" -> "foldM\'_";
"unsafeWith" -> "foldM_";
"unsafeWith" -> "foldl";
"unsafeWith" -> "foldl1";
"unsafeWith" -> "foldl1\'";
"unsafeWith" -> "foldl\'";
"unsafeWith" -> "foldr";
"unsafeWith" -> "foldr1";
"unsafeWith" -> "foldr1\'";
"unsafeWith" -> "foldr\'";
"unsafeWith" -> "forM";
"unsafeWith" -> "forM_";
"unsafeWith" -> "force";
"unsafeWith" -> "freeze";
"unsafeWith" -> "fromList";
"unsafeWith" -> "fromListN";
"unsafeWith" -> "generate";
"unsafeWith" -> "generateM";
"unsafeWith" -> "getPtr";
"unsafeWith" -> "head";
"unsafeWith" -> "headM";
"unsafeWith" -> "ifilter";
"unsafeWith" -> "ifoldM";
"unsafeWith" -> "ifoldM\'";
"unsafeWith" -> "ifoldM\'_";
"unsafeWith" -> "ifoldM_";
"unsafeWith" -> "ifoldl";
"unsafeWith" -> "ifoldl\'";
"unsafeWith" -> "ifoldr";
"unsafeWith" -> "ifoldr\'";
"unsafeWith" -> "iforM";
"unsafeWith" -> "iforM_";
"unsafeWith" -> "imap";
"unsafeWith" -> "imapM";
"unsafeWith" -> "imapM_";
"unsafeWith" -> "imapMaybe";
"unsafeWith" -> "imapMaybeM";
"unsafeWith" -> "indexM";
"unsafeWith" -> "indexed";
"unsafeWith" -> "init";
"unsafeWith" -> "iscanl";
"unsafeWith" -> "iscanl\'";
"unsafeWith" -> "iscanr";
"unsafeWith" -> "iscanr\'";
"unsafeWith" -> "iterateN";
"unsafeWith" -> "iterateNM";
"unsafeWith" -> "izipWith";
"unsafeWith" -> "izipWith3";
"unsafeWith" -> "izipWith4";
"unsafeWith" -> "izipWith5";
"unsafeWith" -> "izipWith6";
"unsafeWith" -> "izipWithM";
"unsafeWith" -> "izipWithM_";
"unsafeWith" -> "last";
"unsafeWith" -> "lastM";
"unsafeWith" -> "length";
"unsafeWith" -> "map";
"unsafeWith" -> "mapM";
"unsafeWith" -> "mapM_";
"unsafeWith" -> "mapMaybe";
"unsafeWith" -> "mapMaybeM";
"unsafeWith" -> "maxIndex";
"unsafeWith" -> "maxIndexBy";
"unsafeWith" -> "maximum";
"unsafeWith" -> "maximumBy";
"unsafeWith" -> "minIndex";
"unsafeWith" -> "minIndexBy";
"unsafeWith" -> "minimum";
"unsafeWith" -> "minimumBy";
"unsafeWith" -> "modify";
"unsafeWith" -> "not";
"unsafeWith" -> "notElem";
"unsafeWith" -> "null";
"unsafeWith" -> "or";
"unsafeWith" -> "partition";
"unsafeWith" -> "partitionWith";
"unsafeWith" -> "postscanl";
"unsafeWith" -> "postscanl\'";
"unsafeWith" -> "postscanr";
"unsafeWith" -> "postscanr\'";
"unsafeWith" -> "prescanl";
"unsafeWith" -> "prescanl\'";
"unsafeWith" -> "prescanr";
"unsafeWith" -> "prescanr\'";
"unsafeWith" -> "product";
"unsafeWith" -> "readPrec";
"unsafeWith" -> "replicate";
"unsafeWith" -> "replicateM";
"unsafeWith" -> "reverse";
"unsafeWith" -> "scanl";
"unsafeWith" -> "scanl1";
"unsafeWith" -> "scanl1\'";
"unsafeWith" -> "scanl\'";
"unsafeWith" -> "scanr";
"unsafeWith" -> "scanr1";
"unsafeWith" -> "scanr1\'";
"unsafeWith" -> "scanr\'";
"unsafeWith" -> "setPtr";
"unsafeWith" -> "showsPrec";
"unsafeWith" -> "singleton";
"unsafeWith" -> "slice";
"unsafeWith" -> "snoc";
"unsafeWith" -> "span";
"unsafeWith" -> "splitAt";
"unsafeWith" -> "sum";
"unsafeWith" -> "tail";
"unsafeWith" -> "take";
"unsafeWith" -> "takeWhile";
"unsafeWith" -> "thaw";
"unsafeWith" -> "toList";
"unsafeWith" -> "uncons";
"unsafeWith" -> "unfoldr";
"unsafeWith" -> "unfoldrExactN";
"unsafeWith" -> "unfoldrExactNM";
"unsafeWith" -> "unfoldrM";
"unsafeWith" -> "unfoldrN";
"unsafeWith" -> "unfoldrNM";
"unsafeWith" -> "uniq";
"unsafeWith" -> "unsafeAccum";
"unsafeWith" -> "unsafeAccumulate";
"unsafeWith" -> "unsafeAccumulate_";
"unsafeWith" -> "unsafeBackpermute";
"unsafeWith" -> "unsafeCopy";
"unsafeWith" -> "unsafeDrop";
"unsafeWith" -> "unsafeFreeze";
"unsafeWith" -> "unsafeHead";
"unsafeWith" -> "unsafeHeadM";
"unsafeWith" -> "unsafeIndex";
"unsafeWith" -> "unsafeIndexM";
"unsafeWith" -> "unsafeInit";
"unsafeWith" -> "unsafeLast";
"unsafeWith" -> "unsafeLastM";
"unsafeWith" -> "unsafeSlice";
"unsafeWith" -> "unsafeTail";
"unsafeWith" -> "unsafeTake";
"unsafeWith" -> "unsafeThaw";
"unsafeWith" -> "unsafeUpd";
"unsafeWith" -> "unsafeUpdate";
"unsafeWith" -> "unsafeUpdate_";
"unsafeWith" -> "unsnoc";
"unsafeWith" -> "unstablePartition";
"unsafeWith" -> "unzip";
"unsafeWith" -> "unzip3";
"unsafeWith" -> "unzip4";
"unsafeWith" -> "unzip5";
"unsafeWith" -> "unzip6";
"unsafeWith" -> "updPtr";
"unsafeWith" -> "update";
"unsafeWith" -> "update_";
"unsafeWith" -> "xs";
"unsafeWith" -> "zip";
"unsafeWith" -> "zip3";
"unsafeWith" -> "zip4";
"unsafeWith" -> "zip5";
"unsafeWith" -> "zip6";
"unsafeWith" -> "zipWith";
"unsafeWith" -> "zipWith3";
"unsafeWith" -> "zipWith4";
"unsafeWith" -> "zipWith5";
"unsafeWith" -> "zipWith6";
"unsafeWith" -> "zipWithM";
"unsafeWith" -> "zipWithM_";
"unsafeWrite" -> "length";
"unsafeWrite" -> "v";
"unsnoc" -> "length";
"unsnoc" -> "unsafeInit";
"unsnoc" -> "v";
"unsnoc" -> "xs";
"unstablePartition" -> "b";
"unstablePartition" -> "length";
"unstablePartition" -> "stream";
"unstablePartition" -> "unsafeRead";
"unstablePartition" -> "unsafeWrite";
"unstablePartition" -> "unstablePartition_stream";
"unstablePartition" -> "v";
"unstablePartitionBundle" -> "partitionUnknown";
"unstablePartitionBundle" -> "s";
"unstablePartitionBundle" -> "unstablePartitionMax";
"unstablePartitionBundle" -> "upperBound";
"unstablePartitionBundle" -> "v";
"unstablePartitionMax" -> "s";
"unstablePartitionMax" -> "unsafeNew";
"unstablePartitionMax" -> "unsafeSlice";
"unstablePartitionMax" -> "unsafeWrite";
"unstablePartitionMax" -> "v";
"unstablePartition_new" -> "unsafeDrop";
"unstablePartition_new" -> "unsafeFreeze";
"unstablePartition_new" -> "unsafeTake";
"unstablePartition_new" -> "v";
"unstablePartition_stream" -> "s";
"unstablePartition_stream" -> "unsafeFreeze";
"unstablePartition_stream" -> "v";
"unstream" -> "munstream";
"unstream" -> "new";
"unstream" -> "s";
"unstream" -> "v";
"unstreamM" -> "s";
"unstreamM" -> "unstream";
"unstreamM" -> "v";
"unstreamM" -> "xs";
"unstreamPrimM" -> "s";
"unstreamPrimM" -> "unsafeFreeze";
"unstreamPrimM" -> "v";
"unstreamPrimM_IO" -> "s";
"unstreamPrimM_IO" -> "unstreamPrimM";
"unstreamPrimM_IO" -> "v";
"unstreamPrimM_ST" -> "unstreamPrimM";
"unstreamPrimM_ST" -> "v";
"unstreamR" -> "munstreamR";
"unstreamR" -> "new";
"unstreamR" -> "s";
"unstreamR" -> "v";
"unzip" -> "b";
"unzip" -> "map";
"unzip" -> "v";
"unzip" -> "xs";
"unzip3" -> "b";
"unzip3" -> "map";
"unzip3" -> "v";
"unzip3" -> "xs";
"unzip4" -> "b";
"unzip4" -> "map";
"unzip4" -> "v";
"unzip4" -> "xs";
"unzip5" -> "b";
"unzip5" -> "map";
"unzip5" -> "v";
"unzip5" -> "xs";
"unzip6" -> "b";
"unzip6" -> "map";
"unzip6" -> "v";
"unzip6" -> "xs";
"updPtr" -> "b";
"updPtr" -> "clear";
"updPtr" -> "clone";
"updPtr" -> "copy";
"updPtr" -> "drop";
"updPtr" -> "grow";
"updPtr" -> "init";
"updPtr" -> "length";
"updPtr" -> "modify";
"updPtr" -> "move";
"updPtr" -> "new";
"updPtr" -> "null";
"updPtr" -> "overlaps";
"updPtr" -> "read";
"updPtr" -> "replicate";
"updPtr" -> "replicateM";
"updPtr" -> "s";
"updPtr" -> "set";
"updPtr" -> "slice";
"updPtr" -> "splitAt";
"updPtr" -> "swap";
"updPtr" -> "tail";
"updPtr" -> "take";
"updPtr" -> "unsafeCast";
"updPtr" -> "unsafeCoerceMVector";
"updPtr" -> "unsafeCopy";
"updPtr" -> "unsafeDrop";
"updPtr" -> "unsafeFromForeignPtr";
"updPtr" -> "unsafeFromForeignPtr0";
"updPtr" -> "unsafeGrow";
"updPtr" -> "unsafeInit";
"updPtr" -> "unsafeModify";
"updPtr" -> "unsafeMove";
"updPtr" -> "unsafeNew";
"updPtr" -> "unsafeRead";
"updPtr" -> "unsafeSlice";
"updPtr" -> "unsafeSwap";
"updPtr" -> "unsafeTail";
"updPtr" -> "unsafeTake";
"updPtr" -> "unsafeToForeignPtr";
"updPtr" -> "unsafeToForeignPtr0";
"updPtr" -> "unsafeWith";
"updPtr" -> "unsafeWrite";
"updPtr" -> "write";
"update" -> "b";
"update" -> "length";
"update" -> "s";
"update" -> "stream";
"update" -> "unsafeWrite";
"update" -> "update_stream";
"update" -> "v";
"update_" -> "stream";
"update_" -> "update_stream";
"update_" -> "v";
"update_stream" -> "modifyWithBundle";
"update_stream" -> "v";
"upperBound" -> "and";
"upperBound" -> "catMaybes";
"upperBound" -> "cmpBy";
"upperBound" -> "concatMap";
"upperBound" -> "concatMapM";
"upperBound" -> "cons";
"upperBound" -> "drop";
"upperBound" -> "dropWhile";
"upperBound" -> "dropWhileM";
"upperBound" -> "elem";
"upperBound" -> "empty";
"upperBound" -> "enumFromStepN";
"upperBound" -> "enumFromThenTo";
"upperBound" -> "enumFromTo";
"upperBound" -> "eqBy";
"upperBound" -> "filter";
"upperBound" -> "filterM";
"upperBound" -> "find";
"upperBound" -> "findIndex";
"upperBound" -> "findIndexM";
"upperBound" -> "findM";
"upperBound" -> "flatten";
"upperBound" -> "fold1M";
"upperBound" -> "fold1M\'";
"upperBound" -> "foldM";
"upperBound" -> "foldM\'";
"upperBound" -> "foldl";
"upperBound" -> "foldl1";
"upperBound" -> "foldl1M";
"upperBound" -> "foldl1M\'";
"upperBound" -> "foldl1\'";
"upperBound" -> "foldlM";
"upperBound" -> "foldlM\'";
"upperBound" -> "foldl\'";
"upperBound" -> "foldr";
"upperBound" -> "foldr1";
"upperBound" -> "foldr1M";
"upperBound" -> "foldrM";
"upperBound" -> "fromList";
"upperBound" -> "fromListN";
"upperBound" -> "generate";
"upperBound" -> "generateM";
"upperBound" -> "head";
"upperBound" -> "indexed";
"upperBound" -> "indexedR";
"upperBound" -> "init";
"upperBound" -> "iterateN";
"upperBound" -> "iterateNM";
"upperBound" -> "last";
"upperBound" -> "length";
"upperBound" -> "map";
"upperBound" -> "mapM";
"upperBound" -> "mapM_";
"upperBound" -> "mapMaybe";
"upperBound" -> "mapMaybeM";
"upperBound" -> "notElem";
"upperBound" -> "null";
"upperBound" -> "or";
"upperBound" -> "postscanl";
"upperBound" -> "postscanlM";
"upperBound" -> "postscanlM\'";
"upperBound" -> "postscanl\'";
"upperBound" -> "prescanl";
"upperBound" -> "prescanlM";
"upperBound" -> "prescanlM\'";
"upperBound" -> "prescanl\'";
"upperBound" -> "replicate";
"upperBound" -> "replicateM";
"upperBound" -> "scanl";
"upperBound" -> "scanl1";
"upperBound" -> "scanl1M";
"upperBound" -> "scanl1M\'";
"upperBound" -> "scanl1\'";
"upperBound" -> "scanlM";
"upperBound" -> "scanlM\'";
"upperBound" -> "scanl\'";
"upperBound" -> "singleton";
"upperBound" -> "slice";
"upperBound" -> "snoc";
"upperBound" -> "tail";
"upperBound" -> "take";
"upperBound" -> "takeWhile";
"upperBound" -> "takeWhileM";
"upperBound" -> "toList";
"upperBound" -> "trans";
"upperBound" -> "unbox";
"upperBound" -> "unfoldr";
"upperBound" -> "unfoldrExactN";
"upperBound" -> "unfoldrExactNM";
"upperBound" -> "unfoldrM";
"upperBound" -> "unfoldrN";
"upperBound" -> "unfoldrNM";
"upperBound" -> "uniq";
"upperBound" -> "zip";
"upperBound" -> "zip3";
"upperBound" -> "zip4";
"upperBound" -> "zip5";
"upperBound" -> "zip6";
"upperBound" -> "zipWith";
"upperBound" -> "zipWith3";
"upperBound" -> "zipWith3M";
"upperBound" -> "zipWith4";
"upperBound" -> "zipWith4M";
"upperBound" -> "zipWith5";
"upperBound" -> "zipWith5M";
"upperBound" -> "zipWith6";
"upperBound" -> "zipWith6M";
"upperBound" -> "zipWithM";
"upperBound" -> "zipWithM_";
"v" -> "unsafeIndex";
"v" -> "v";
"vmunstream" -> "s";
"vmunstream" -> "upperBound";
"vmunstream" -> "v";
"vmunstream" -> "vmunstreamMax";
"vmunstream" -> "vmunstreamUnknown";
"vmunstreamMax" -> "length";
"vmunstreamMax" -> "s";
"vmunstreamMax" -> "unsafeNew";
"vmunstreamMax" -> "unsafeSlice";
"vmunstreamMax" -> "v";
"vmunstreamUnknown" -> "delay_inline";
"vmunstreamUnknown" -> "enlarge_delta";
"vmunstreamUnknown" -> "length";
"vmunstreamUnknown" -> "s";
"vmunstreamUnknown" -> "unsafeGrow";
"vmunstreamUnknown" -> "unsafeNew";
"vmunstreamUnknown" -> "unsafeSlice";
"vmunstreamUnknown" -> "v";
"vunstream" -> "s";
"vunstream" -> "v";
"vunstream" -> "vmunstream";
"write" -> "length";
"write" -> "unsafeWrite";
"write" -> "v";
"xs" -> "b";
"xs" -> "v";
"zip" -> "b";
"zip" -> "v";
"zip" -> "zipWith";
"zip3" -> "b";
"zip3" -> "v";
"zip3" -> "zipWith3";
"zip4" -> "b";
"zip4" -> "v";
"zip4" -> "zipWith4";
"zip5" -> "b";
"zip5" -> "v";
"zip5" -> "zipWith5";
"zip6" -> "b";
"zip6" -> "v";
"zip6" -> "zipWith6";
"zipWith" -> "b";
"zipWith" -> "stream";
"zipWith" -> "unstream";
"zipWith" -> "v";
"zipWith" -> "xs";
"zipWith" -> "zipWithM";
"zipWith3" -> "b";
"zipWith3" -> "stream";
"zipWith3" -> "unstream";
"zipWith3" -> "v";
"zipWith3" -> "zipWith3M";
"zipWith3M" -> "b";
"zipWith3M" -> "fromStream";
"zipWith3M" -> "smaller";
"zipWith4" -> "b";
"zipWith4" -> "stream";
"zipWith4" -> "unstream";
"zipWith4" -> "v";
"zipWith4" -> "zipWith4M";
"zipWith4M" -> "b";
"zipWith4M" -> "v";
"zipWith4M" -> "zip";
"zipWith4M" -> "zipWithM";
"zipWith5" -> "b";
"zipWith5" -> "stream";
"zipWith5" -> "unstream";
"zipWith5" -> "v";
"zipWith5" -> "zipWith5M";
"zipWith5M" -> "b";
"zipWith5M" -> "v";
"zipWith5M" -> "zip";
"zipWith5M" -> "zip3";
"zipWith5M" -> "zipWithM";
"zipWith6" -> "b";
"zipWith6" -> "stream";
"zipWith6" -> "unstream";
"zipWith6" -> "v";
"zipWith6" -> "zipWith6M";
"zipWith6M" -> "b";
"zipWith6M" -> "v";
"zipWith6M" -> "zip3";
"zipWith6M" -> "zipWithM";
"zipWithM" -> "b";
"zipWithM" -> "fromStream";
"zipWithM" -> "lift";
"zipWithM" -> "smaller";
"zipWithM" -> "stream";
"zipWithM" -> "unstreamM";
"zipWithM" -> "v";
"zipWithM_" -> "b";
"zipWithM_" -> "consume";
"zipWithM_" -> "lift";
"zipWithM_" -> "stream";
"zipWithM_" -> "v";
"zipWithM_" -> "zipWithM";
}
