\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{array}
\usepackage{graphicx}
\usepackage{parskip}
\usepackage[pdfencoding=auto]{hyperref}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{tikz}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage{caption}
\usepackage{authblk}
\usepackage{longtable}
\usepackage[acronym]{glossaries}
\usepackage[nottoc]{tocbibind}
\usepackage[cache=false]{minted}
\usemintedstyle{default}
\newminted{haskell}{frame=lines,framerule=2pt}
\newminted{R}{frame=lines,framerule=2pt}
\graphicspath{{./images/}}

\tikzstyle{bag} = [align=center]

\title{%
      Analysis of Software Design Principles \\
      under Complex Network Theory\\
}
\author{Juan Pablo Royo Sales \& Francesc Roy Campderrós}
\affil{Universitat Politècnica de Catalunya}
\date\today

\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{}
\fancyhead[R]{UPC MIRI}
\fancyhead[L]{CSN - Final Work}
\fancyfoot[L,C]{}
\fancyfoot[R]{Page \thepage{} of \pageref{LastPage}}
\setlength{\headheight}{15pt}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\newacronym{netdyn}{Network Dynamics}{Network Dynamics}
\newacronym{degdist}{Degree Distribution}{Degree Distribution}
\newacronym{growdeg}{Time Growth Degree}{Growth of Vertex Degree over time}
\newacronym{prefatt}{G Pref Attachment}{Growth + Preferential Attachment}
\newacronym{randatt}{G Random Attachment}{Growth + Random Attachment}
\newacronym{nprefatt}{NG Pref Attachment}{No Growth + Preferential Attachment}
\newacronym{baral}{Barabasi-Albert model}{Barabasi-Albert model}
\newacronym{indegree}{Incomming Degree}{Incomming Degree Language Set}
\newacronym{zeta}{Zeta}{Zeta Model}
\newacronym{aic}{Akaike}{Akaike Information Criterion}
\newacronym{dispp}{Displaced Poisson}{Displaced Poisson Model}
\newacronym{dispg}{Displaced Geometric}{Displaced Geometric Model}
\newacronym{hc}{High Cohesion}{High Cohesion}
\newacronym{lc}{Low Coupling}{Low Coupling}
\newacronym{cnt}{Complex Network Theory}{Complex Network Theory}
\newacronym{fp}{Functional Programming}{Functional Programming}
\newacronym{oop}{Object Oriented Programming}{Object Oriented Programming}
\newacronym{loc}{LoC}{Lines of Code}

\newtheorem{hyp}{Hypothesis}

\begin{document}

\maketitle

\tableofcontents

\section{Introduction}
One of the most well known Software Design principles in \textbf{Software Engineering} is \acrfull{hc} and \acrfull{lc}, which is well described here~\cite{cohesion_coupling}.

As this two principles states a \textit{robust Software} should be design with \acrlong{lc} between their modules and \acrlong{hc} inside it. 

In other words, a Software that fullfil this characteristics should be very connected in their minimum functional units (Functions inside same file, Methods inside a class, etc), and with few connections between their coarse grained functional units (a.k.a Modules or Packages).

In this work, we are going to formulate some hypothesis which we believe it can been empirically proved and shown the relationship between these principles and how to measure with \textbf{\acrfull{cnt}}.
At the same time, we are going to analysis different kinds of software of different sizes and build under different language paradigms to see if the tool set that \acrshort{cnt} provides are suitable for the general case. 

\section{Preliminaries}
In this section we are going to describe how and why the different Language Paradigms are selected and what is the criterion for selection of different Software solutions to be evaluated.

On the other hand as well, we are going to formulate some hypothesis that are going to guide our work to see if our assumptions can empirically been proved using \acrlong{cnt}.

\subsection{Context}
We have selected the most important $2$ main Language Paradigm to conduct the analysis: \acrfull{fp} and \acrfull{oop}. 

The reasons behind this decision are basically the following:

\begin{itemize}
    \item \textbf{95\%} of Software in the Industry are built with one of these 2 Paradigms according to the last results of this well-known survey~\cite{so_survey}.
    \item Due to the intrinsic nature of each of those Paradigms we have some hypothesis that we are going to describe later that can lead to different conclusion and Metrics
    \item If we can deduce some Software Design properties analyzing these 2 Paradigms we can generalize for the rest because they are quite different in nature and covers almost the whole Industry.
    \item We also believe that Software Principles should apply indistinguishably the Paradigm. 
\end{itemize}


\subsection{Hypothesis}
In this work we are trying to prove the following \textbf{Hypothesis} that we consider can be proved using \acrfull{cnt}.

\begin{hyp}
Given any Software Program Solution, its Network Metrics should be in the percentil $.95$ according to the average of the Network Metrics that we have been identified in this work.
\end{hyp}

\begin{hyp}
Any \acrlong{oop} Program have a better modularity in terms of \acrlong{cnt} Metric rather than \acrlong{fp} Programs.
\end{hyp}

\begin{hyp}
The more \acrfull{loc} a Program have, the better Modularity it presents.
\end{hyp}
    

\section{Results}
\subsection{Experiments}
\subsection{Metrics}

\section{Discussion and Analysis}
\section{Conclusions}

\bibliographystyle{alpha}
\bibliography{Report}

\appendix
\section{Organization}

\begin{itemize}
    \item \textbf{code}: Under this folder you are going to find \textit{C++} code for simulating and generating the different networks using the different strategies: \acrfull{prefatt}, \acrfull{randatt} and \acrfull{nprefatt}, as well as the \textit{R} scripts for generating plots and doing graph analysis.
    \item \textbf{code/data}: Data Generated for each strategy
    \item \textbf{report}: This report in Latex and PDF format.
\end{itemize}

\section{FP Analytzed Programs}
\begin{longtable}[H]{l r l}
    \caption{FP Analyzed Programs}\label{table:fp_prog_1}\\
        Program & LoC & Repository \\
        \hline            
        \endhead
        aeson & 6948 & https://github.com/haskell/aeson.git \\
        amazonka & 715531 & https://github.com/brendanhay/amazonka \\
        async & 743 & https://github.com/simonmar/async.git \\
        attoparsec & 4718 & https://github.com/haskell/attoparsec.git \\
        beam & 20151 & https://github.com/haskell-beam/beam.git \\
        cabal & 102525 & https://github.com/haskell/cabal.git \\
        co-log & 1436 & https://github.com/kowainik/co-log \\
        conduit & 12963 & https://github.com/snoyberg/conduit \\
        containers & 19556 & https://github.com/haskell/containers.git \\
        criterion & 2421 & https://github.com/haskell/criterion.git \\
        cryptol & 30740 & https://github.com/GaloisInc/cryptol \\
        cryptonite & 18763 & https://github.com/haskell-crypto/cryptonite.git \\
        dhall & 29058 & https://github.com/dhall-lang/dhall-haskell.git \\
        free & 4472 & https://github.com/ekmett/free.git \\
        fused-effects & 4145 & https://github.com/fused-effects/fused-effects.git \\
        ghcid & 1664 & https://github.com/ndmitchell/ghcid.git \\
        haskoin & 12066 & https://github.com/haskoin/haskoin-core.git \\
        hedgehog & 8277 & https://github.com/hedgehogqa/haskell-hedgehog.git \\
        helm & 2071 & https://github.com/z0w0/helm.git \\
        hlint & 6306 & https://github.com/ndmitchell/hlint.git \\
        lens & 16691 & https://github.com/ekmett/lens.git \\
        liquid & 133740 & https://github.com/ucsd-progsys/liquidhaskell.git \\
        megaparsec & 8144 & https://github.com/mrkkrp/megaparsec.git \\
        mios & 6178 & https://github.com/shnarazk/mios.git \\
        mtl & 932 & https://github.com/haskell/mtl.git \\
        optparse & 3220 & https://github.com/pcapriotti/optparse-applicative.git \\
        pandoc & 69179 & https://github.com/jgm/pandoc.git \\
        pipes & 1969 & https://github.com/Gabriel439/Haskell-Pipes-Library.git \\
        postgresql & 6596 & https://github.com/haskellari/postgresql-simple.git \\
        protolude & 1901 & https://github.com/protolude/protolude \\
        quickcheck & 5077 & https://github.com/nick8325/quickcheck.git \\
        reflex & 10062 & https://github.com/reflex-frp/reflex.git \\
        relude & 2913 & https://github.com/kowainik/relude \\
        servant & 15725 & https://github.com/haskell-servant/servant.git \\
        snap & 5310 & https://github.com/snapframework/snap.git \\
        stm & 1550 & https://github.com/haskell/stm.git \\
        summoner & 4025 & https://github.com/kowainik/summoner \\
        text & 9783 & https://github.com/haskell/text.git \\
        vector & 12166 & https://github.com/haskell/vector.git \\
        yesod & 19971 & https://github.com/yesodweb/yesod.git \\
        small & 449 & PRIVATE \\
        PRIVATE PROGRAM & 26975 & PRIVATE \\
    
\end{longtable}


\end{document}

