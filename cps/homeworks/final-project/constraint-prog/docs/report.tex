\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{tikz}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage{caption}
\usepackage[acronym]{glossaries}
\usepackage[nottoc]{tocbibind}
\usepackage[cache=true]{minted}
\usemintedstyle{default}
\graphicspath{{./images/}}
\newminted{cpp}{frame=lines,framerule=2pt}

\tikzstyle{bag} = [align=center]

\lstset{frame=tb,
  language=Haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2,
  stepnumber=1,
  escapechar=!
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\title{%
      Combinatorial Problem Solving \\
      Final Project - Box Wrapping
}
\author{%
  Juan Pablo Royo Sales \\
  \small{Universitat Polit√®cnica de Catalunya}
}
\date\today

\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{}
\fancyhead[R]{Juan Pablo Royo Sales - UPC MIRI}
\fancyhead[L]{CPS - Final Project}
\fancyfoot[L,C]{}
\fancyfoot[R]{Page \thepage{} of \pageref{LastPage}}
\setlength{\headheight}{15pt}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\DeclareMathOperator*{\argmax}{argmax} % thin space, limits underneath in displays

\newacronym{cp}{CP}{Constraint Programming}
\newacronym{bsp}{BSP}{Best Success Principle}
\newacronym{ffp}{FFP}{Fail First Principle}
\newacronym{bab}{BAB}{Branch and Bound}

\begin{document}

\maketitle

\section{Constraint Programming}

\subsection{Predefinitions}
Values given by the state the of the program.

\begin{itemize}
  \item $1 \leq W \leq 11$ maximum width paper roll
  \item $L$ maximum length paper roll. By definition is infinite
  \item $N = \{1, \dots, n\}$ total number of Boxes
  \item $w_b$ Width of the Box $b, b \in N$
  \item $h_b$ Height of the Box $b, b \in N$
\end{itemize}

\subsection{Formal Definition}
Given the statement of the problem proposed, we are going to define the following variables for our \acrfull{cp} solution.

\subsubsection{Variables}
\begin{itemize}
  \item $l$ is the length of paper needed for the current configuration
  \item $x_b^{tl}$: Top \textbf{left} corner $x$. Means the box $b$ is on the top left $x$-coordinate.
  \item $y_b^{tl}$: Top \textbf{left} corner $y$. Means the box $b$ is on the top left $y$-coordinate.
  \item $x_b^{br}$: Bottom \textbf{right} corner $x$. Means the box $b$ is on the bottom right $x$-coordinate.
  \item $y_b^{br}$: Bottom \textbf{right} corner $y$. Means the box $b$ is on the bottom right $y$-coordinate.
  \item $r_b$: Boolean Array that indicates if the Box $b$ is rotated or not.
\end{itemize}

As we can see this variables are obvious from the statement problem in section \textbf{2.2 Output Format} Paragraph 2 and 3.

\subsubsection{Domains}
\begin{itemize}
  \item $l = \{1,\dots,n\}$
  \item $x_b^{tl} = \{0,\dots,W-1\}, b \in N$
  \item $y_b^{tl} = \{0,\dots,L-1\}, b \in N$
  \item $x_b^{br} = \{0,\dots,W-1\}, b \in N$
  \item $y_b^{br} = \{0,\dots,L-1\}, b \in N$
  \item $r_b = \{0,1\}, b \in N$
\end{itemize}


\subsubsection{Constraints}

\begin{enumerate}
  \item $x_b^{tl} \leq x_b^{br}\ \forall b \in N$: Each top left $x$ coordinate must be less or equal than the bottom right $x$-coordinate in each Box.
  \item $y_b^{tl} \leq y_b^{br}\ \forall b \in N$: Each top left $y$-coordinate must be less or equal than the bottom right $y$-coordinate in each Box.
  \item\label{c:4} $x_b^{br} \leq W\ \forall b \in N$: There is no bottom right $x$-coordinate that is longer that the maximum width of paper roll $W$.
\item\label{c:5} $x_b^{br} = x_b^{tl} + (w_b - 1)\ \forall b \in N, r_b = 0$: If the Box is not rotated the amount of $x$ coordinates that occupies it is the width of the box.
\item\label{c:6} $y_b^{br} = y_b^{tl} + (h_b - 1)\ \forall b \in N, r_b = 0$: If the Box is not rotate the amount of $y$-coordinates that occupies it is the height of the box.
\item $x_b^{br} = x_b^{tl} + (h_b - 1)\ \forall b \in N, r_b = 1$: Same as~\ref{c:5} but the amount of $x$-coordinates that occupies is the height because it is rotated.
  \item $y_b^{br} = y_b^{tl} + (w_b - 1)\ \forall b \in N, r_b = 1$: Same as~\ref{c:6} but the amount of $y$-coordinates that occupies is the width because it is rotated.
  \item\label{c:7} $x_{b_i}^{tl} + w_{b_i} - 1 < x_{b_j}^{tl} \lor y_{b_i}^{tl} + h_{b_i} - 1 < y_{b_j}^{tl}, \ \forall b_i > b_j \in N, i \neq j, r_{b_i} = 0$: Not overlap boxes for non rotated $i$.
  \item $x_{b_i}^{tl} + h_{b_i} - 1 < x_{b_j}^{tl} \lor y_{b_i}^{tl} + w_{b_i} - 1 < y_{b_j}^{tl}, \ \forall b_i > b_j \in N, i \neq j, r_{b_i} = 1$: Same as~\ref{c:7} for rotated $i$.
  \item\label{c:8} $x_{b_i}^{tl} < x_{b_j}^{tl}\ \forall b_i, b_j \in N,\ i \neq j,\ w_{b_i} \times h_{b_i} \geq w_{b_j} \times h_{b_j}$: For each pair of boxes try to put first the bigger box.
  \item $y_{b_i}^{tl} < y_{b_j}^{tl}\ \forall b_i, b_j \in N,\ i \neq j,\ w_{b_i} \times h_{b_i} \geq w_{b_j} \times h_{b_j}$: Same as~\ref{c:8} But for $y$ coordinates
  \item $x_b^{tl} = 0,\ b = 1$: Break column symmetry. At least first box should be on the most left half of the roll width.
   \item $y_b^{tl} = 0,\ b = 1$: Break row symmetry. At least first box should be on the top half of the roll length.
  \item $l = \argmax_{y_b^{br}} {b \in N}$: Length of the roll at the end cannot be larger than the biggest bottom right $y$-coordinate.
\end{enumerate}

\subsection{Optimization and Improvements}
\subsubsection{Constraint Optimization}
Regarding constraint optimization I am implemented the \textbf{length} optimization of the roll paper which is the final goal of the problem: Putting all boxes such as we are minimizing the used length. This is done in the \mintinline{cpp}{constrain} method during \acrfull{bab}.

\begin{listing}[H]
\begin{cppcode*}{}
  virtual void constrain(const Space& boxWrap) {
    const BoxWrapping& oldBox = static_cast<const BoxWrapping&>(boxWrap);
    rel(*this, length < oldBox.length);
  }
\end{cppcode*}
\caption{Branch and Bound Constraint Optimization}
\label{lst:constrain}
\end{listing}



\subsubsection{Variable - Value Selection}
The branch and bound strategy it is being implemented only on 3 Array variables of the model: $x_tl$, $y_tl$ and $r_b$. This is because the other 2 arrays which are the bottom rights, are calculated based on the constraints stated in the previous section and not need to do a value or var selection for that.

I have implemented the following strategies for the variable and value selection:

\begin{itemize}
  \item \textbf{$x_b^{tl}$ Variable Selection}: I am doing a \acrfull{bsp} strategy, that state to try to choose those variable that will lead to solution first. In the case of the problem I am doing a \mintinline{cpp}{tiebreak} between the \mintinline{cpp}{INT_VAR_SIZE_MIN} and the box which is bigger in order to put first the \textbf{bigger} boxes. Although I am doing a descending sort based on the size of the boxes at the beginning of the program, I am also constraint this by the Gecode.


\begin{listing}[H]
\begin{cppcode*}{}
  double merit_aux(int i) const{
    return boxes.boxArea(i);
  }

  static double merit(const Space& home, IntVar x, int i){
    return static_cast<const BoxWrapping&>(home).merit_aux(i);
  }

  branch(*this, x_tl,
                tiebreak(INT_VAR_SIZE_MIN(),
                         INT_VAR_MERIT_MAX(&merit)),
                INT_VAL(&value));
\end{cppcode*}
\caption{Branch and Bound on $x_b^{tl}$ - Variable Selection}
\label{lst:branch_var_x_tl}
\end{listing}

\item \textbf{$x_b^{tl}$ Value Selection}: In the case of value selection, since we are selecting the indexes in which the box are going to be positioned, we want first to try to fill the width first to take advantage of the width roll. In this case in the \mintinline{cpp}{value} custom method I am trying to see according to the bottom right $x$ coordinates that has been assigned, if there is still free space to put the current box to the right of the last assigned $x_b^{br}$ box.


\begin{listing}[H]
\begin{cppcode*}{}
  int value_aux(IntVar x, int i) const {
    int max = 0;
    for(int i = 0; i<boxes.size(); i++){
      if(x_br[i].assigned()){
        if(max <= x_br[i].val()){
          max = x_br[i].val();
        }
      }
    }
    int r = x.min();
    for (IntVarValues k(x); k( ) ; ++k) {
      int j  = k.val();
      if(max < boxes.getWidth()-1 && j > max && j < r){
        r = j;
      }
    }
    return r;
  }

  static int value(const Space& home, IntVar x, int i) {
    return static_cast<const BoxWrapping&>(home).value_aux(x, i);
  }

  branch(*this, x_tl,
                tiebreak(INT_VAR_SIZE_MIN(),
                         INT_VAR_MERIT_MAX(&merit)),
                INT_VAL(&value));
\end{cppcode*}
\caption{Branch and Bound on $x_b^{tl}$ - Value Selection}
\label{lst:branch_val_x_tl}
\end{listing}

\item\label{item:var_y_b_tl} \textbf{$y_b^{tl}$ Variable Selection}: In the case of $y$ top left coordinate variable selection I am following the same strategy as $x$-coordinate because we want to prioritize bigger boxes.

\begin{listing}[H]
\begin{cppcode*}{}
  double merit_aux(int i) const{
    return boxes.boxArea(i);
  }

  static double merit(const Space& home, IntVar x, int i) {
    return static_cast<const BoxWrapping&>(home).merit_aux(i);
  }

  branch(*this, y_tl,
                tiebreak(INT_VAR_SIZE_MIN(), INT_VAR_MERIT_MAX(&merit)),
                INT_VAL_MIN());
\end{cppcode*}
\caption{Branch and Bound on $y_b^{tl}$ - Variable Selection}
\label{lst:branch_var_y_tl}
\end{listing}

\item \textbf{$y_b^{tl}$ Value Selection}: In this case as it can be seen~\ref{item:var_y_b_tl} the selection of the value is the minimum because we want to fill fill from top down roll.

\item \textbf{$r_b$ - Selection}: In this case which are the variables that indicate rotation I am following a default strategy and simple select \mintinline{ccp}{BOOL_VAL_MIN} in the case of value which indicate that it is going to be prioritize NO rotation first.

\begin{listing}[H]
\begin{cppcode*}{}
  branch(*this, r_b, BOOL_VAR_NONE(), BOOL_VAL_MIN());
\end{cppcode*}
\caption{Branch and Bound on $r_b$ - Selection}
\label{lst:branch_r_b}
\end{listing}

\end{itemize}




\end{document}

