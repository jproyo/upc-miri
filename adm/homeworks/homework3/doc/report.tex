\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{tikz}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage{caption}
\usepackage[acronym]{glossaries}
\usepackage[nottoc]{tocbibind}
\usepackage[cache=false]{minted}
\usemintedstyle{default}
\newminted{haskell}{frame=lines,framerule=2pt}
\graphicspath{{./images/}}

\tikzstyle{bag} = [align=center]

\title{%
      Homework 3 \\
      Experimental Comparison between KDTrees vs. Locality Sensitivity Hashing
}
\author{%
  Juan Pablo Royo Sales \\
  \small{Universitat Polit√®cnica de Catalunya}
}
\date\today

\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{}
\fancyhead[R]{Juan Pablo Royo Sales - UPC MIRI}
\fancyhead[L]{ADM - Homework 3}
\fancyfoot[L,C]{}
\fancyfoot[R]{Page \thepage{} of \pageref{LastPage}}
\setlength{\headheight}{15pt}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\makeglossaries

\newacronym{lsh}{LSH}{Locality Sensitivity Hashing}
\newacronym{kdt}{KDTree}{KDTrees}
\newacronym{nns}{NNS}{Nearest Neighbor Search}
\newacronym{haskell}{Haskell}{Haskell Programming Language}
\newacronym{kde}{KDE}{Kernel Density Estimate}
\newacronym{lrm}{LRM}{Linear Regression Model}

\begin{document}

\maketitle

\section{Introduction}\label{sec:intro}
In this work, I am going to show the experimental results of comparing \acrfull{lsh} vs. \acrfull{kdt} for doing \acrfull{nns} algorithm as a good predictor.

In previous works \cite{hmw1} and \cite{hmw2} I've done a deep analysis on how this Data Structures work in order to achieve good asymptotic cost for doing \acrshort{nns} and predict values.

In this work I have done an implementation of both Data Structures in Haskell \acrfull{haskell}.

In the following sections I am going to describe where it can be found each source of information and code as well as the experiments run and the results.

\section{Asset organization}
Please check the appendix~\ref{apx:org} to see how the different assets are organized, how to run the experiment, and so on.

\section{Data Source}
\subsection{Static Data}
The data source used for this experiment is the \textbf{Transactional Grocery Store} data accorded with the teacher that can be found in~\ref{apx:data}.

I have chosen this data in agreement with the teacher because we want to experiment on high dimensional transactional data.

This data source contains \textbf{1000} records of transactional data with at most \textbf{15} dimensions.

The data set is divided into:

\begin{itemize}
  \item 800 Rows of Training Data
  \item 200 Rows of Testing Data
\end{itemize}

\subsection{Randomized Data}\label{sub:sec:random:data}
For randomization experiments, I am generating $100000$ records with 15 dimensions each of positive integer values each.

For that I am using a \acrshort{haskell} library called QuickCheck \cite{QuickCheck}.

After generating the points I am splitting up in Training and Test Data Set of equal size $50000$

   \begin{listing}[H]
    \inputminted[firstline=11, lastline=15]{haskell}{../app/random/Main.hs}
    \caption{Extracted from source code app/random/Main.hs}
    \label{src:main:random}
   \end{listing}



\subsection{Sanitizing Data}
Since the data is not structured and each record contains different dimension we need to sanitize somehow in order to be able to feed the algorithm for further processing.

In the case of \acrshort{lsh} implementation, I don't need this sanitation because my implementation works on set of value hashing, so different combinations of unstructured record which are similar will lead to the same hash bucket.

On the other hand, in the case of \acrshort{kdt}, I am going to need to sanitize this data because since \acrshort{kdt} is a multidimensional data structure, all the dimensional points are need to be represented in a structured way.

For that reason I have done the following sanitation:

\begin{itemize}
  \item Having different records of that like:

    \inputminted[firstline=2, lastline=12]{text}{../input/data.in}

  \item I took all the different possible dimensional labels
    \begin{listing}[H]
    \inputminted[firstline=91, lastline=108]{haskell}{../src/IO/Data.hs}
    \caption{Extracted from source code src/IO/Data.hs}
    \label{src:io:data:1}
    \end{listing}

  \item With for each record I create a dimensional point of 15 dimension with Bits values that indicates $1$ if the dimension is present in the record, $0$ otherwise.
    \begin{listing}[H]
    \inputminted[firstline=72, lastline=82]{haskell}{../src/IO/Data.hs}
    \caption{Extracted from source code src/IO/Data.hs}
    \label{src:io:data:2}
    \end{listing}

\end{itemize}

\section{Experiments Details}
As I pointed out in the Introduction section~\ref{sec:intro}, I have already analyzed theoretical properties of these two Data Structures in the previous homework. Therefore, the main goal of this work is to focus in the experimental comparison.

In order to do that, I have defined 3(\textbf{three}) experiments.

\begin{itemize}
  \item \textbf{Benchmark}
  \item \textbf{Qualitative}
  \item \textbf{Randomized Benchmark}
\end{itemize}

\subsection{Benchmark}\label{sub:sec:bench}
This experiment consist in measuring and comparing the empirical performance on both data structures. For that I have used a very well known \acrshort{haskell} library \cite{criterion}.

Basically this library run several samples of the same process to take statistical analysis of the running time of the process. With that statistical information it builds a \acrfull{kde} graphic and a \acrfull{lrm}.

The benchmarking experiments are going to be focus on the following comparisons:

\begin{itemize}
  \item Running time of loading Training Data Set on \acrshort{lsh}
  \item Running time of loading Training Data Set on \acrshort{kdt}
  \item Running time of performing \acrshort{nns} on each Test Data Set on \acrshort{lsh}
  \item Running time of performing \acrshort{nns} on each Test Data Set on \acrshort{kdt}
\end{itemize}

\subsection{Qualitative}
Qualitative analysis is basically load the training data, and after that for each row of the Testing Data Set, run \acrshort{nns} in order to see and analyze each result.

\subsection{Randomized Benchmark}
Randomized Benchmark is the same kind of experiment as Benchmark~\ref{sub:sec:bench} but the difference is that I am using randomized generated data to train and search in the model.

This experiment I have done in order to test the performance of the Data Structures with a lot of data since $1000$ records it is not too much.

In order to see details about randomized data generation check subsection~\ref{sub:sec:random:data}

\section{Results}

\section{Conclusions}

\bibliographystyle{alpha}
\bibliography{report}

\printglossary[type=\acronymtype]

\appendix\label{apx:org}
\section{Haskell}
\subsection{Source Code}
In the source code there are 2 folders with code:

\begin{itemize}
  \item \textbf{app}: Which contains 3 programs with the 3 executables source code file. Here we can find:
    \begin{itemize}
      \item \textbf{\mintinline{haskell}{app/bench/Main.hs}}: It is the main entry point that run the Benchmark analysis in both Data Structures.
      \item \textbf{\mintinline{haskell}{app/data/Main.hs}}: It is the main entry point that run the A Qualitative analysis in both Data Structures to see what is the output on each case.
      \item \textbf{\mintinline{haskell}{app/random/Main.hs}}: It is the main entry point that run a Benchmark but based on Random generate data in both Data Structures.
    \end{itemize}
  \item \textbf{src}: Contains the implementation source code of the Data Structures.
    \begin{itemize}
      \item \textbf{\mintinline{haskell}{src/Experiments.hs}}: It contains the different experiment run.
      \item \textbf{\mintinline{haskell}{src/Data/LSH/LSH.hs}}: \acrshort{lsh} Implementation.
      \item \textbf{\mintinline{haskell}{src/Data/Tree/KDTree.hs}}: \acrshort{kdt} Implementation.
      \item \textbf{\mintinline{haskell}{src/Data/Types.hs}}: Usefull types to handle 15 dimensional points.
      \item \textbf{\mintinline{haskell}{src/IO/Data.hs}}: Handle reading dataset from file, sanitizing and transforming to be fed into implementations. Also partition the data between training and test set.
    \end{itemize}

\end{itemize}

\subsection{Run the Code}
All the solution has been coded with \textbf{Stack} \cite{stack} version 2.1.3 or higher. It is a prerequisite to install \textit{stack} for running this code.

\subsubsection{Running Experiments}
In order to run the experiments just do the following in each case.

\begin{itemize}
  \item \textbf{Benchmark Experiment}

\begin{minted}{bash}
stack build
stack exec lsh-kdtree-bench -- --output MY_OUTPUT_FILE.html
\end{minted}

This is going to left an HTML report with the benchmark results in \mintinline{bash}{MY_OUTPUT_FILE.html}

\item \textbf{Randomized Benchmark Experiment}

\begin{minted}{bash}
stack build
stack exec lsh-kdtree-random -- --output MY_OUTPUT_FILE.html
\end{minted}

This is going to left an HTML report with the randomized benchmark results in \mintinline{bash}{MY_OUTPUT_FILE.html}


\item \textbf{Qualitative Data Experiment}

\begin{minted}{bash}
stack build
stack exec lsh-kdtree-data
\end{minted}

This is going to print a summarized result, but it is going to left \textbf{csv} files under \mintinline{haskell}{output} directory with a timestamp suffix to identified the run, where you can find that for every tested data case what is the \acrshort{nns} result.

\end{itemize}

\section{Data Source - Input}\label{apx:data}
Input data or Data Source is being store under \mintinline{haskell}{input} folder.

\section{Generated Reports}
All the Generated Reports that has been used to build this document are under \mintinline{haskell}{output} folder.

\section{Report PDF Document}
This report document is under \mintinline{haskell}{doc} folder alongside images that are embedded in this report.


\end{document}

