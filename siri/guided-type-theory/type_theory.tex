\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{array}
\usepackage{graphicx}
\usepackage{parskip}
\usepackage[pdfencoding=auto]{hyperref}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{tikz}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage{caption}
\usepackage{authblk}
\usepackage{longtable}
\usepackage{bussproofs}
\usepackage{flagderiv}
\usepackage[acronym]{glossaries}
\usepackage[nottoc]{tocbibind}
\usepackage[cache=false]{minted}
\usemintedstyle{default}
\newminted{haskell}{frame=lines,framerule=2pt}
\newminted{R}{frame=lines,framerule=2pt}
\graphicspath{{./images/}}

\tikzstyle{bag} = [align=center]

\title{%
      A Report of \textit{Type Theory and Formal Proof}
}
\author{Juan Pablo Royo Sales}
\affil{Universitat Politècnica de Catalunya}
\date\today

\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{}
\fancyhead[R]{UPC MIRI}
\fancyhead[L]{SIRI - Guided Work}
\fancyfoot[L,C]{}
\fancyfoot[R]{Page \thepage{} of \pageref{LastPage}}
\setlength{\headheight}{15pt}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\newacronym{lc}{$\lambda$-\textit{calculus}}{Lambda Calculus}
\newacronym{br}{$\beta$-\textit{reduction}}{Beta Reduction}
\newacronym{lt}{$\lambda$-\textit{term}}{Lambda Terms}

\newcommand{\twobeta}{\twoheadrightarrow_\beta}
\newcommand{\onebeta}{\to_\beta}
\newcommand{\deriv}{\quad\vdash\quad}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem*{exercise}{}

\begin{document}

\maketitle

\tableofcontents

\section{Introduction}
This report is going to provide a summary over the book~\cite{type_theory}.
Alongside the different chapters of the book I am going to describe briefly the most important parts of each chapter and, at the same time,
I am going to solve 1 or 2 of the exercises proposed by the authors.

The organization of the report is going to be the same as the chapters of the book.

\section{Untyped lambda calculus}
In this first chapter the authors define and describe \acrfull{lc} system which encapsulates the formalization of basic aspects
of mathematical functions, in particular construction and use. In \acrshort{lc} formalization system there are \textit{typed} and \textit{untyped} 
formalization of the same system. In this first case authors introduced the first basic and simple formalization which is \textit{untyped}.

\subsection{Definition}
There are \textit{two constructions principles} and \textit{one evaluation rule}

\textbf{Construction principles:}

\begin{itemize}
    \item \textit{Abstraction:} Given an expression $M$ and a variable $x$ we can construct the expression: $\lambda x.M$. This is abstraction of $x$ over $M$
    Example: $\lambda y.(\lambda x. x - y)$ Abstraction of $y$ over $\lambda x. x - y$
    \item \textit{Application:} Given 2 expressions $M$ and $N$ we can construct the expression: $M\ N$. This is the application of $M$ to $N$.
    Example: $(\lambda x.x^2 + 1)(3)$ Application of $3$ over $\lambda x.x^2 + 1$
\end{itemize}

\textbf{Evaluation Rule:} Formalization of this process is called \acrfull{br}. 
\acrshort{br}: An expression $(\lambda x. M)N$ can be rewritten to $M[x := N]$, which means every $x$ should be replaced by $N$ in $M$. This process 
is called \acrshort{br} of $(\lambda x. M)N$ to $M[x := N]$.

Example: $(\lambda x. x^2 + 1)(3)$ reduces to $(x^2 + 1)[x := 3]$, which is $3^2 + 1$.

In this book, functions on \acrshort{lc} notation are \textit{Curried}.

\subsubsection{Lambda-terms}
Expressions in \acrshort{lc} are called \acrfull{lt}

\begin{definition}
    The set $\Lambda$ of all \acrshort{lt}
\end{definition}

\begin{enumerate}
    \item (Variable) If $u \in V$, then $u \in \Lambda$ \\
    Example: $x$, $y$, $z$
    \item (Application) If $M$ and $N \in \Lambda$, then $(MN) \in \Lambda$  \\
    Example: $(x y)$, $(x(x y))$
    \item (Abstraction) If $u \in V$ and $M \in \Lambda$, then $(\lambda u. M) \in \Lambda$  \\
    Example: $(\lambda x. (x z))$, $(\lambda y. (\lambda z. x))$
\end{enumerate}


\begin{definition}
    Multiset of subterms $Sub$
\end{definition}

\begin{enumerate}
    \item (Basis) $Sub(x) = \{x\}$, for each $x \in V$
    \item (Application) $Sub((MN)) = Sub(M) \cup Sub(N) \cup \{(MN)\}$
    \item (Abstraction) $Sub((\lambda x. M)) = Sub(M) \cup \{(\lambda x. M)\}$
\end{enumerate}

\begin{lemma}
    (1) (Reflexivity) For all \acrshort{lt} $M$, we have $M \in Sub(M)$. 
    (2) (Transitivity) If $L \in Sub(M)$ and $M \in Sub(N)$, then $L \in Sub(N)$.
\end{lemma}

\begin{definition}[Proper subterm]
    $L$ is a proper subterm of $M$ if $L$ is a subterm of $M$, but $L \not\equiv M$
\end{definition}

\begin{itemize}
    \item Parenthesis can be omitted
    \item Application is lef-associative, $MNL$ is $((MN)L)$
    \item Application takes precedence over Abstraction
\end{itemize}

\subsection{Free and bound variables}
Variables can be \textit{free}, \textit{bound} and \textit{binding}. A variable $x$ which is \textit{free} in $M$ becomes \textit{bound}
in $\lambda x. M$. $M$ is called a \textit{binding} variable occurrence.
\begin{definition}[FV, set of free variables of a \acrshort{lt}]
\end{definition}
\begin{enumerate}
    \item (Variable) $FV(x) = \{x\}$
    \item (Application) $FV(MN) = FV(M) \cup FV(N)$
    \item (Abstraction) $FV(\lambda x. M) = FV(M) \setminus \{x\}$
\end{enumerate}

\begin{definition}[Closed \acrshort{lt}; combinator; $\Lambda^0$]
    The \acrshort{lt} $M$ is closed if $FV(M) = \emptyset$. This is also called a combinator.
    The set of all closed \acrshort{lt} is denoted by $\Lambda^0$ 
\end{definition}

\subsubsection{Alpha conversion}
It is based on the possibility of renaming bound and binding variables.

\begin{definition}[Renaming; $M^{x \to y}$; $=_\alpha$]\label{def:6}
    Let $M^{x \to y}$ denote the result of replacing every free ocurrence of $x$ in $M$ by $y$.
    Renaming, expressed by $=_\alpha$ is defined as: $\lambda x. M =_\alpha \lambda y. M^{x \to y}$, provided
    that $y \notin FV(M)$ and $y$ is not binding in $M$
\end{definition}

\begin{definition}[$\alpha$-convertion or $\alpha$-equivalence; $=_\alpha$]
\end{definition}
\begin{enumerate}
    \item (Renaming) same as~\ref{def:6}
    \item (Compatibility) If $M =_\alpha N$, then $ML =_\alpha NL$, $LM =_\alpha LN$ and, for any arbitrary $z$, $\lambda z. M =_\alpha \lambda z. N$\label{def:comp}
    \item (Reflexivity) $M =_\alpha M$
    \item (Symmetry) If $M =_\alpha N$ then $N =_\alpha M$
    \item (Transitivity) If both $L =_\alpha M$ and $M =_\alpha N$, then $L =_\alpha N$
\end{enumerate}

\subsection{Substitution}
\begin{definition}[Substitution]
\end{definition}
\begin{enumerate}
    \item $x[x := N] \equiv N$
    \item $y[x := N] \equiv y$ if $x \not\equiv y$
    \item $(PQ)[x := N] \equiv (P[x := N])(Q[x := N])$
    \item $(\lambda y. P)[x := N] \equiv \lambda z. (P^{y \to z}[x := N])$, if $\lambda z. P^{y \to z}$ is $\alpha$-variant of $\lambda y.P$ such that $z \notin FV(N)$
\end{enumerate}

\subsection{Beta reduction}\label{subsection:beta:reduction}
\begin{definition}[One-step $\beta$-reduction, $\onebeta$]    
\end{definition}
\begin{enumerate}
    \item (Basis) $(\lambda x. M)N \onebeta M[x := N]$,\label{def:9:1}
    \item (Compatibility) If $M \onebeta N$, then $ML \onebeta NL$, $LM \onebeta LN$ and $\lambda x. M \onebeta \lambda x. N$
\end{enumerate}

In~\ref{def:9:1} the left part of $\onebeta$ is called \textit{redex} (reducible expression), and the right
side is called \textit{contractum} (of the redex).

\begin{definition}[$\beta$-reduction (zero-or-more-step), $\twobeta$]
$M \twobeta N$ if there is an $n \geq 0$ and there are terms $M_0$ to $M_n$ such that $M_0 \equiv M$, $M_n \equiv N$ and for all $i, 0 \leq i < n$:\\
$M_i \onebeta M_{i+1}$
\end{definition}
Hence, if $M \twobeta N$, there exists a chain of single-step $\beta$-reductions, starting with $M$ and ending with $N$:

$M \equiv M_0 \onebeta M_1 \onebeta M_2 \onebeta \dots \onebeta M_{n-2} \onebeta M_{n-1} \onebeta M_n \equiv N$

\begin{definition}[$\beta$-conversion, $\beta$-equality; $=_\beta$]
    $M =_\beta N$ if there is an $n \geq 0$ and there are terms $M_0$ to $M_n$ such that $M_0 \equiv M$, $M_n \equiv N$ and for all $i, 0 \leq i < n$:\\
    either $M_i \onebeta M_{i+1}$ or $M_{i+1} \onebeta M_i$
\end{definition}

\subsection{Fixed Point Theorem}
\begin{theorem}
    For all $L \in \Lambda$ there is $M \in \Lambda$ such that $LM =_\beta M$
\end{theorem}
\begin{proof}
    For given $L$, define $M := (\lambda x. L(xx))(\lambda x. L(xx))$
    This $M$ is a redex, so we have:
    \begin{subequations}
        \begin{align}
            M &\equiv (\lambda x. L(xx))(\lambda x. L(xx))\\
              &\onebeta L((\lambda x. L(xx))(\lambda x. L(xx)))\\
              &\equiv LM
        \end{align}
    \end{subequations}
Therefore, $LM =_\beta M$
\end{proof}

\subsection{Exercises}
\subsubsection{1.10 Church numerals}
Having that:
\begin{itemize}
    \item $zero \ := \lambda fx. x$
    \item $one \ := \lambda fx. fx$
    \item $two \ := \lambda fx. f(fx)$
    \item $add \ := \lambda mnfx. mf(nfx)$
    \item $mult \ := \lambda mnfx. m(nf)x$
\end{itemize}
\begin{exercise}[a]
    Show that: $(add\ one\ one\ \twobeta\ two)$
\end{exercise}
\begin{proof}
    Replacing by lambda expressions
    \begin{subequations}
        \begin{align}
            add\ one\ one\ &:= (\lambda mnfx. mf(nfx))(\lambda fx. fx)(\lambda fx. fx)\\
            &\onebeta (\lambda nfx. (\lambda fx. fx)f(nfx))(\lambda fx. fx)\\
            &\onebeta (\lambda fx. (\lambda fx. fx)f((\lambda fx. fx)fx))\\
            &\onebeta (\lambda fx. (\lambda fx. fx)f(fx))\\
            &\onebeta (\lambda fx. f(fx))\\
            &:= two
        \end{align}
    \end{subequations}
\end{proof}

\begin{exercise}[b]
    Show that: $(\text{add one one }\neq_\beta \text{ mult one zero})$
\end{exercise}
\begin{proof}
    We need to reduce $(\textit{mult one zero})$ and show that is not \textit{two}
    \begin{subequations}
        \begin{align}
            mult\ one\ zero\ &:= (\lambda mnfx. m(nf)x)(\lambda fx. fx)(\lambda fx. x)\\
            &\onebeta (\lambda nfx. (\lambda fx. fx)(nf)x)(\lambda fx. x)\\
            &\onebeta (\lambda fx. (\lambda fx. fx)((\lambda fx. x)f)x)\\
            &\onebeta (\lambda fx. (\lambda x. ((\lambda fx. x)f)x)x)\\
            &\onebeta (\lambda fx. (\lambda x. (\lambda x. x)x)x)\\
            &\onebeta (\lambda fx. (\lambda x. x)x)\\
            &\onebeta (\lambda fx. x)\\
            &:= zero
        \end{align}
    \end{subequations}
\end{proof}
\subsubsection{1.11 - Successor}
Having that $\textit{suc} := \lambda mfx. f(mfx)$. Check the following
\begin{exercise}[a]
    suc zero $=_\beta$ one
\end{exercise}
\begin{proof}
    \begin{subequations}
        \begin{align}
            \textit{suc zero } &=_\beta (\lambda mfx. f(mfx))(\lambda fx.x)\\
            &\onebeta (\lambda fx. f((\lambda fx.x)fx))\\
            &\onebeta (\lambda fx. f((\lambda x.x)x))\\
            &\onebeta (\lambda fx. fx)\\
            &:= one
        \end{align}
    \end{subequations}
\end{proof}

\begin{exercise}[b]
    suc one $=_\beta$ two
\end{exercise}
\begin{proof}
    \begin{subequations}
        \begin{align}
            \textit{suc one } &=_\beta (\lambda mfx. f(mfx))(\lambda fx.fx)\\
            &\onebeta (\lambda fx. f((\lambda fx.fx)fx))\\
            &\onebeta (\lambda fx. f((\lambda x.fx)x))\\
            &\onebeta (\lambda fx. f(fx))\\
            &:= two
        \end{align}
    \end{subequations}
\end{proof}

\subsubsection{1.12 - If then else}
The term 'If $x$ then $u$ else $v$' is represented by $\lambda x. xuv$. Check this by
calculating $\beta$-normal forms of $(\lambda x. xuv)\text{true}$ and $(\lambda x. xuv)\text{false}$, having that:
\begin{itemize}
    \item $\textit{true } := \lambda xy. x$
    \item $\textit{false } := \lambda xy. y$
\end{itemize}

\begin{proof}[$(\lambda x. xuv)\text{true}$]
    \begin{subequations}
        \begin{align}
            &:= (\lambda x. xuv)(\lambda xy. x)\\
            &\onebeta (\lambda xy. x)uv\\
            &\onebeta (\lambda y. u)v\\
            &\onebeta u\\
        \end{align}
    \end{subequations}
\end{proof}

\begin{proof}[$(\lambda x. xuv)\text{false}$]
    \begin{subequations}
        \begin{align}
            &:= (\lambda x. xuv)(\lambda xy. y)\\
            &\onebeta (\lambda xy. y)uv\\
            &\onebeta (\lambda y. y)v\\
            &\onebeta v\\
        \end{align}
    \end{subequations}
\end{proof}

\section{Simply typed lambda calculus}
In this chapter authors introduce \textbf{\textit{Types}} to \acrshort{lc} Formalization system.
When we are acting on mathematical functions, the natural thing is to restrict over some domain, both the image and the pre-image.
The addition of types to the formalization system prevents some anomalies that are present in the regular \acrshort{lc} model.

\subsection{Simple types}
It is done adding type \textit{variables} with an infinite set $\mathbb{V} = \{\alpha,\beta,\gamma,\dots\}$

\begin{definition}[The set $\mathbb{T}$ of all simple types]
\end{definition}
\begin{enumerate}
    \item (Type variable) If $\alpha \in \mathbb{V}$, then $\alpha \in \mathbb{T}$
    \item (Arrow type) If $\sigma, \tau \in \mathbb{T}$, then $(\sigma \to \tau) \in \mathbb{T}$
\end{enumerate}
Also, $\mathbb{T} = \mathbb{V} \mid \mathbb{T} \to \mathbb{T}$.

Parenthesis in \textit{arrow types} are right-\textit{associative}

\subsubsection{Remarks}
\begin{itemize}
    \item \textit{Type variable} represent simple types like \textit{Nat, Lists, etc.}
    \item \textit{Arrow types} represent functions such as $\textit{nat } \to \textit{ real}$
    \item \textit{'term $M$ has type $\sigma$'} (typing statement) is represented as $M : \sigma$
    \item \textit{'variable $x$ has type $\sigma$'} is represented as $x : \sigma$
    \item If $x : \sigma$ and $x : \tau$ then $\sigma \equiv \tau$
    \item \textit{Application}: If $M : \sigma \to \tau$ and $N : \sigma$, then $MN : \tau$ 
    \item \textit{Abstraction}: If $x : \sigma$ and $M : \tau$, then $\lambda x. M : \sigma \to \tau$ 
\end{itemize}

\subsection{Church-typing and Curry-typing}
\subsubsection{Typing à la Church}
Unique type for each variable upon its introduction~\cite{church}.

\textbf{Example}: If $x$ has type $\alpha \to \alpha$ and $y$ has type $(\alpha \to \alpha) \to \beta$, then $yx$ has type $\beta$.

If $z$ has type $\beta$ and $u$ has type $\gamma$, then $\lambda zu.z$ has type $\beta \to \gamma \to \beta$.
Therefore application $(\lambda zu.z)(yx)$ is permitted.

\subsubsection{Typing à la Curry}
Not give the types of variables, leave them \textit{implicit}, therefore is called \textit{implicit typing}.

\textbf{Example}: Suppose we have $M \equiv (\lambda zu.z)(yx)$ but types are not given. 
Guessing we have $\lambda zu.z$ should have some type $A \to B$, so $(yx)$ must be of type $A$, then $M$ is of type $B$.
If we continue with the guessing assigning type variables after replacing we end up with the same expression as explicit typing.

Most of the book use \textit{Typing a la Church} because in math and logic types are usually fixed and known beforehand.

\subsection{Derivation rules for Church's \texorpdfstring{$\lambda\to$}{Lg}}
\begin{definition}[Pre-typed \acrshort{lt}, $\Lambda_{\mathbb{T}}$]
\end{definition}
\begin{equation}
    \Lambda_{\mathbb{T}} = V \mid (\Lambda_{\mathbb{T}}\Lambda_{\mathbb{T}}) \mid (\lambda V : \mathbb{T}.\Lambda_{\mathbb{T}})
\end{equation}
We want to express things like '\acrshort{lt} $M$ has type $\sigma$' relative to context $\Gamma$

\begin{definition}[Statement, declaration, context, judgement]
\end{definition}
\begin{enumerate}
    \item \textbf{Statement}: $M : \sigma$, where $M \in \Lambda_{\mathbb{T}}$ and $\sigma \in \mathbb{T}$. $M$ is called \textit{subject} and $\sigma$ \textit{type}
    \item \textbf{Declaration}: Is a statement with a \textit{variable} as subject. Example $x : \alpha \to \beta$ç
    \item \textbf{Context}: List of Declarations with different subjects
    \item \textbf{Judgement}: $\Gamma \deriv M : \sigma$, where $\Gamma$ is a \textit{Context} and $M :  \sigma$ is a \textit{Statement}.
\end{enumerate}

\begin{definition}[Derivation rules for $\lambda\to$]
\end{definition}
\begin{itemize}
    \item[(\textit{var})] $\Gamma \deriv x : \sigma$ if $x : \sigma \in \Gamma$
    \item[(\textit{appl})] 
    \AxiomC{$\Gamma \deriv M : \sigma \to \tau$}
    \AxiomC{$\Gamma \deriv N : \sigma$} 
    \BinaryInfC{$\Gamma \deriv MN : \tau$} 
    \DisplayProof
    \item[(\textit{abst})] 
    \AxiomC{$\Gamma, x : \sigma \deriv M : \tau$} 
    \UnaryInfC{$\Gamma \deriv \lambda x : \sigma . M : \sigma \to \tau$} 
    \DisplayProof
\end{itemize}

This rules are \textbf{\textit{universal}}.

\begin{definition}[Legal $\lambda\to$-terms]
    A pre-typed term $M$ in $\lambda\to$ is called \textbf{\textit{legal}} if there exist a context $\Gamma$ and type $\rho$ such that $\Gamma \deriv M : \rho$
\end{definition}

\subsubsection{Example}
\begin{prooftree}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \deriv y : \alpha \to \beta$}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \deriv z : \alpha$}
    \BinaryInfC{$y : \alpha \to \beta, z : \alpha \deriv yz : \beta$} 
    \UnaryInfC{$y : \alpha \to \beta \deriv \lambda z : \alpha . yz : \alpha \to \beta$} 
    \UnaryInfC{$\emptyset \deriv \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : (\alpha \to \beta) \to \alpha \to \beta$} 
\end{prooftree}


\subsection{Derivation formats}
\subsubsection{Linear format}

\begin{enumerate}
    \item $y : \alpha \to \beta, z : \alpha \deriv y : \alpha \to \beta \quad \textit{(var)}$\label{s:1}
    \item $y : \alpha \to \beta, z : \alpha \deriv z : \alpha \quad \textit{(var)}$\label{s:2}
    \item $y : \alpha \to \beta, z : \alpha \deriv yz : \beta \quad \textit{(appl) on \ref{s:1} and \ref{s:2}}$\label{s:3}
    \item $y : \alpha \to \beta \deriv \lambda z : \alpha . yz : \alpha \to \beta \quad \textit{(abst) on \ref{s:3}}$\label{s:4}
    \item $\emptyset \deriv \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : (\alpha \to \beta) \to \alpha \to \beta \quad \textit{(abst) on \ref{s:4}}$
\end{enumerate}

\subsubsection{Flag notation}
Flag notation is a succinct and useful way to represent Derivation rules on Typed-\acrshort{lc}. It is represented using a \textit{flag} (rectangular box)
as a declaration, and everything that is bellow and attached to this \textit{flag} are statements that belong to it. This is also called \textit{flag pole}.
Lets see an example of derivation:

We can translate \textit{linear format} into \textit{flag notation}:

\begin{flagderiv}
    \assume{ctx:1}{y : \alpha \to \beta}{}
    \assume{ctx:2}{z : \alpha}{}
    \step{var:1}{y : \alpha \to \beta}{(var) on \ref{ctx:1}}
    \step{var:2}{z : \alpha}{(var) on \ref{ctx:2}}
    \step{appl:1}{yz : \beta}{(appl) on \ref{var:1} and \ref{var:2}}
    \conclude{abst:1}{\lambda z : \alpha . yz : \alpha \to \beta}{(abst) on \ref{appl:1}}
    \conclude{abst:2}{\lambda y : \alpha \to \beta . \lambda z : \alpha . yz : (\alpha \to \beta) \to \alpha \to \beta}{(abst) on \ref{abst:1}}
  \end{flagderiv}

Even more succinct without \textit{var} rule:

\begin{flagderiv}
    \assume{a:1:1}{y : \alpha \to \beta}{}
    \assume{a:1:2}{z : \alpha}{}
    \step{s:1:1}{yz : \beta}{(appl) on \ref{a:1:1} and \ref{a:1:2}}
    \conclude{c:1:1}{\lambda z : \alpha . yz : \alpha \to \beta}{(abst) on \ref{s:1:1}}
    \conclude{}{\lambda y : \alpha \to \beta . \lambda z : \alpha . yz : (\alpha \to \beta) \to \alpha \to \beta}{(abst) on \ref{c:1:1}}
  \end{flagderiv}

\subsection{Problems solved with judgement in Type Theory}

\begin{itemize}
    \item Well-typedness in $\lambda\to$
    \item Type Checking in $\lambda\to$
    \item Term finding in $\lambda\to$
\end{itemize}

\subsubsection{Well-typedness in \texorpdfstring{$\lambda\to$}{Lg}}
Find out when a term is legal: 

$ ? \deriv \text{ term } :\ ?$ 

We want to show that a \acrshort{lt} $M$ is legal or not. This is done following the derivation tree and 
trying to find a context $\Gamma$ an a type $\rho$ such that $\Gamma \deriv M : \rho$

In our previous example of derivation if we start checking that the term $\lambda y : \alpha \to \beta . \lambda z : \alpha . yz : ?$ is legal.
If we check with our flag notation from bottom up in the derivation tree, we are going to find the context in which this term is legal, but for example
if that term would have been $\lambda y : \alpha \to \beta . \lambda z : \beta . yz : ?$, we have not because $z : \beta$ cannot be applied to $y$.

\subsubsection{Type Checking in \texorpdfstring{$\lambda\to$}{Lg}}
It is checking the validity of a full \textit{judgement}.
Given the following: 

$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \deriv (\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta$

\begin{flagderiv}
    \assume{}{x : \alpha \to \alpha}{}
    \assume{}{y : (\alpha \to \alpha) \to \beta}{}
    \skipsteps*{\vdots}{}
    \conclude{}{(\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta}{}
  \end{flagderiv}

The idea is to fill the dots:

\begin{flagderiv}
    \assume{a:2:1}{x : \alpha \to \alpha}{}
    \assume{a:2:2}{y : (\alpha \to \alpha) \to \beta}{}
    \step{s:2:1}{\lambda z : \beta . \lambda u : \gamma . z :\ ?_1}{}
    \skipsteps*{\vdots}{}
    \step{s:2:2}{yx :\ ?_2}{}
    \conclude{}{(\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta}{(appl) on \ref{s:2:1} and \ref{s:2:2}, (?)}
  \end{flagderiv}

  \begin{flagderiv}
    \assume{a:3:1}{x : \alpha \to \alpha}{}
    \assume{a:3:2}{y : (\alpha \to \alpha) \to \beta}{}
    \assume{a:3:3}{z : \beta}{}
    \assume{a:3:4}{u : \gamma}{}
    \step{s:3:0}{z : \beta}{(var) on \ref{a:3:3}}
    \conclude{c:3:0}{\lambda u : \gamma . z : \gamma \to \beta}{(abst) on \ref{s:3:0}}
    \conclude{c:3:1}{\lambda z : \beta . \lambda u : \gamma . z : \beta \to \gamma \to \beta}{(abst) on \ref{c:3:0}}
    \step{s:3:2}{yx : \beta}{(appl) on \ref{a:3:1} and \ref{a:3:2}}
    \conclude{}{(\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta}{(appl) on \ref{c:3:1} and \ref{s:3:2}, (?)}
  \end{flagderiv}

\subsubsection{Term finding in \texorpdfstring{$\lambda\to$}{Lg}}
Finding an appropriated term of certain type, in a certain context. A \textit{term} that belongs to certain type is called \textbf{\textit{inhabitant}} of that type.

This process is constructed starting with an empty context and exploring the situation on which the type is an expression from logic: \textit{a proposition}. Every inhabitant then codes a \textit{proof}
of this proposition, hence declaring it to be a 'true' one.

\textbf{Procedure:}
\begin{itemize}
    \item Take $A \to B \to A$ as a logical expression. This is a \textit{tautology}
    \item Assume $A$ holds. 
    \item Assume $B$ holds, then $A$ holds.
\end{itemize}

\begin{flagderiv}
    \assume{a:4:1}{x : A}{}
    \skipsteps*{\vdots}{}
    \step{s:4:1}{?\ : B \to A}{}
    \skipsteps*{\vdots}{}
    \conclude{c:4:1}{\dots A \to B \to A}{(abst) on \ref{s:4:1}}
  \end{flagderiv}

  \begin{flagderiv}
    \assume{a:5:1}{x : A}{}
    \assume{a:5:1}{y : B}{}
    \skipsteps*{\vdots}{}
    \step{s:5:0}{?\ : A \to A}{}
    \conclude{c:5:0}{\dots : B \to A}{(abst) on \ref{s:5:0}}
    \conclude{}{\dots A \to B \to A}{(abst) on \ref{c:5:0}}
  \end{flagderiv}

  \begin{flagderiv}
    \assume{a:6:1}{x : A}{}
    \assume{a:6:2}{y : B}{}
    \step{s:6:1}{x : A}{(var) on \ref{a:6:1}}
    \conclude{c:6:1}{\lambda y : B. x : B \to A}{(abst) on \ref{s:6:1}}
    \conclude{}{\lambda x : A. \lambda y : B. x : A \to B \to A}{(abst) on \ref{c:6:1}}
  \end{flagderiv}

\subsection{General properties of \texorpdfstring{$\lambda\to$}{Lg}}
\begin{definition}[Domain, $\mathtt{dom}$, subcontext, $\subseteq$, permutation, projection, $\restriction$]
\end{definition}
\begin{enumerate}
    \item If $\Gamma \equiv x_1 : \sigma_1, \dots, x_n : \sigma_n$, then the \textit{domain} of $\Gamma$ or $\mathtt{dom}(\Gamma)$ is the list $(x_1,\dots,x_n)$.
    \item $\Gamma'$ is a subcontext of $\Gamma$, or $\Gamma' \subseteq \Gamma$, if all declarations in $\Gamma'$ occurs in $\Gamma$, in the same order.
    \item $\Gamma'$ is a \textit{permutation} of $\Gamma$, if all declarations in $\Gamma'$ also occurs in $\Gamma$ and vice versa.
    \item If $\Gamma$ is a context and $\phi$ a set of variables, the \textit{projection} in $\Gamma$ on $\phi$, or $\Gamma \restriction \phi$, is the subcontext $\Gamma'$ of $\Gamma$ with $\mathtt{dom}(\Gamma') = \mathtt{dom}(\Gamma) \cap \phi$
\end{enumerate}

\begin{lemma}[Free Variables Lemma]
    If $\Gamma \deriv L : \sigma$, then $FV(L) \subseteq \mathtt{dom}(\Gamma)$
\end{lemma}

\begin{lemma}[Thinning, Condensing, Permutation]
\end{lemma}
\begin{enumerate}
    \item (Thinning) Let $\Gamma'$ and $\Gamma''$ be contexts such that $\Gamma' \subseteq \Gamma''$. If $\Gamma' \deriv M : \sigma$, then also $\Gamma'' \deriv M : \sigma$
    \item (Condensing) If $\Gamma \deriv M : \sigma$, then also $\Gamma \restriction FV(M) \deriv M : \sigma$
    \item (Permutation) If $\Gamma \deriv M : \sigma$, and $\Gamma'$ is a permutation of $\Gamma$, then $\Gamma'$ is also a context and $\Gamma' \deriv M : \sigma$
\end{enumerate}

\begin{lemma}[Uniqueness of Types]
    Assume $\Gamma \deriv M : \sigma$, and $\Gamma \deriv M : \tau$, then $\sigma \equiv \tau$
\end{lemma}

\subsection{Reductions and \texorpdfstring{$\lambda\to$}{Lg}}
It is an adapted version of~\ref{subsection:beta:reduction}

\begin{equation}
    (3) (\lambda y : \sigma . P)[x := N] \equiv \lambda z : \sigma . (P^{y \to z}[x := N])
\end{equation}

where $\lambda z : \sigma. P^{y \to z}$ is $\alpha$-variant, such that $z \notin FV(N)$

\begin{lemma}[Substituion Lemma]
    Assume $\Gamma', x : \sigma, \Gamma'' \deriv M : \tau$ and $\Gamma' \deriv N : \sigma$, then $\Gamma', \Gamma'' \deriv M[x := N] : \tau$
\end{lemma}

\begin{definition}[One-step $\beta$-reduction, $\onebeta$, for $\Lambda_{\mathbb{T}}$]
\end{definition}
\begin{enumerate}
    \item (Basis) $(\lambda x : \sigma . M)N \onebeta M [x := N]$
    \item (Compatibility) As~\ref{def:comp}
\end{enumerate}

\subsection{Exercises}
\subsubsection{2.5 Find pre-typed terms}
\begin{exercise}[a]
    $\lambda xy. x(\lambda z. y)y$
\end{exercise}
\begin{proof}
    Having the following:
    \begin{itemize}
        \item Lets assume $x : \sigma \to \beta \to \gamma$, $\lambda z. y : \sigma$ and $y : \beta$
        \item If $z : \rho$, then $\lambda z : \rho. y : \rho \to \beta \equiv \sigma$ should hold.
        \item Taking the assumption $x : (\rho \to \beta) \to \beta \to \gamma$ 
        \item there is a legal term $\lambda x: (\rho \to \beta) \to \beta \to \gamma. \lambda y : \beta. x(\lambda z : \rho . y)y$ with type $((\rho \to \beta) \to \beta \to \gamma) \to \beta \to \gamma$
    \end{itemize}
\end{proof}

\begin{exercise}[b]
    $\lambda xy. x(\lambda z. x)y$
\end{exercise}
\begin{proof}
    Having the following:
    \begin{itemize}
        \item Having similar assumptions as before but $\lambda z. x : \sigma$ and $y : \beta$
        \item If $z : \rho$, then $\lambda z : \rho. x : \rho \to \beta \to \gamma \equiv \sigma$ which does not hold.
    \end{itemize}
    Therefore, term is not typeable.
\end{proof}

\subsubsection{2.9 Type checking}
\begin{exercise}[a]
    $x : \delta \to \delta \to \alpha, y : \gamma \to \alpha, z : \alpha \to \beta \deriv \lambda u : \delta . \lambda v : \gamma . z(yv) : \delta \to \gamma \to \beta$
\end{exercise}
\begin{proof}
  \begin{flagderiv}
    \assume{a:7:1}{x : \delta \to \delta \to \alpha}{}
    \assume{a:7:2}{y : \gamma \to \alpha}{}
    \assume{a:7:3}{z : \alpha \to \beta}{}
    \assume{a:7:4}{u : \delta}{}
    \assume{a:7:5}{v : \gamma}{}
    \step{s:7:1}{yv : \alpha}{(appl) on \ref{a:7:2} and \ref{a:7:5}}
    \step{s:7:2}{z(yv) : \beta}{(appl) on \ref{a:7:3} and \ref{s:7:1}}
    \conclude{c:7:1}{\lambda v : \gamma. z(yv) : \gamma \to \beta}{(abst) on \ref{s:7:2}}
    \conclude{}{\lambda u : \delta . \lambda v : \gamma . z(yv) : \delta \to \gamma \to \beta}{(abst) on \ref{c:7:1}}
  \end{flagderiv}
\end{proof}

\begin{exercise}[b]
    $x : \delta \to \delta \to \alpha, y : \gamma \to \alpha, z : \alpha \to \beta \deriv \lambda u : \delta . \lambda v : \gamma . z(xuu) : \delta \to \gamma \to \beta$
\end{exercise}
\begin{proof}
  \begin{flagderiv}
    \assume{a:8:1}{x : \delta \to \delta \to \alpha}{}
    \assume{a:8:2}{y : \gamma \to \alpha}{}
    \assume{a:8:3}{z : \alpha \to \beta}{}
    \assume{a:8:4}{u : \delta}{}
    \assume{a:8:5}{v : \gamma}{}
    \step{s:8:1}{xuu : \alpha}{(appl) on \ref{a:8:1} and \ref{a:8:4} twice}
    \step{s:8:2}{z(xuu) : \beta}{(appl) on \ref{a:8:3} and \ref{s:8:1}}
    \conclude{c:8:1}{\lambda v : \gamma. z(xuu) : \gamma \to \beta}{(abst) on \ref{s:8:2}}
    \conclude{}{\lambda u : \delta . \lambda v : \gamma . z(xuu) : \delta \to \gamma \to \beta}{(abst) on \ref{c:8:1}}
  \end{flagderiv}
\end{proof}


\bibliographystyle{alpha}
\bibliography{type_theory}

\end{document}


